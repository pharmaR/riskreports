
R version 4.4.1 (2024-06-14 ucrt) -- "Race for Your Life"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "dplyr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "dplyr-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('dplyr')

Attaching package: 'dplyr'

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("across")
> ### * across
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: across
> ### Title: Apply a function (or functions) across multiple columns
> ### Aliases: across if_any if_all
> 
> ### ** Examples
> 
> # For better printing
> iris <- as_tibble(iris)
> 
> # across() -----------------------------------------------------------------
> # Different ways to select the same set of columns
> # See <https://tidyselect.r-lib.org/articles/syntax.html> for details
> iris %>%
+   mutate(across(c(Sepal.Length, Sepal.Width), round))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1            5           4          1.4         0.2 setosa 
 2            5           3          1.4         0.2 setosa 
 3            5           3          1.3         0.2 setosa 
 4            5           3          1.5         0.2 setosa 
 5            5           4          1.4         0.2 setosa 
 6            5           4          1.7         0.4 setosa 
 7            5           3          1.4         0.3 setosa 
 8            5           3          1.5         0.2 setosa 
 9            4           3          1.4         0.2 setosa 
10            5           3          1.5         0.1 setosa 
# ℹ 140 more rows
> iris %>%
+   mutate(across(c(1, 2), round))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1            5           4          1.4         0.2 setosa 
 2            5           3          1.4         0.2 setosa 
 3            5           3          1.3         0.2 setosa 
 4            5           3          1.5         0.2 setosa 
 5            5           4          1.4         0.2 setosa 
 6            5           4          1.7         0.4 setosa 
 7            5           3          1.4         0.3 setosa 
 8            5           3          1.5         0.2 setosa 
 9            4           3          1.4         0.2 setosa 
10            5           3          1.5         0.1 setosa 
# ℹ 140 more rows
> iris %>%
+   mutate(across(1:Sepal.Width, round))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1            5           4          1.4         0.2 setosa 
 2            5           3          1.4         0.2 setosa 
 3            5           3          1.3         0.2 setosa 
 4            5           3          1.5         0.2 setosa 
 5            5           4          1.4         0.2 setosa 
 6            5           4          1.7         0.4 setosa 
 7            5           3          1.4         0.3 setosa 
 8            5           3          1.5         0.2 setosa 
 9            4           3          1.4         0.2 setosa 
10            5           3          1.5         0.1 setosa 
# ℹ 140 more rows
> iris %>%
+   mutate(across(where(is.double) & !c(Petal.Length, Petal.Width), round))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1            5           4          1.4         0.2 setosa 
 2            5           3          1.4         0.2 setosa 
 3            5           3          1.3         0.2 setosa 
 4            5           3          1.5         0.2 setosa 
 5            5           4          1.4         0.2 setosa 
 6            5           4          1.7         0.4 setosa 
 7            5           3          1.4         0.3 setosa 
 8            5           3          1.5         0.2 setosa 
 9            4           3          1.4         0.2 setosa 
10            5           3          1.5         0.1 setosa 
# ℹ 140 more rows
> 
> # Using an external vector of names
> cols <- c("Sepal.Length", "Petal.Width")
> iris %>%
+   mutate(across(all_of(cols), round))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1            5         3.5          1.4           0 setosa 
 2            5         3            1.4           0 setosa 
 3            5         3.2          1.3           0 setosa 
 4            5         3.1          1.5           0 setosa 
 5            5         3.6          1.4           0 setosa 
 6            5         3.9          1.7           0 setosa 
 7            5         3.4          1.4           0 setosa 
 8            5         3.4          1.5           0 setosa 
 9            4         2.9          1.4           0 setosa 
10            5         3.1          1.5           0 setosa 
# ℹ 140 more rows
> 
> # If the external vector is named, the output columns will be named according
> # to those names
> names(cols) <- tolower(cols)
> iris %>%
+   mutate(across(all_of(cols), round))
# A tibble: 150 × 7
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species sepal.length
          <dbl>       <dbl>        <dbl>       <dbl> <fct>          <dbl>
 1          5.1         3.5          1.4         0.2 setosa             5
 2          4.9         3            1.4         0.2 setosa             5
 3          4.7         3.2          1.3         0.2 setosa             5
 4          4.6         3.1          1.5         0.2 setosa             5
 5          5           3.6          1.4         0.2 setosa             5
 6          5.4         3.9          1.7         0.4 setosa             5
 7          4.6         3.4          1.4         0.3 setosa             5
 8          5           3.4          1.5         0.2 setosa             5
 9          4.4         2.9          1.4         0.2 setosa             4
10          4.9         3.1          1.5         0.1 setosa             5
# ℹ 140 more rows
# ℹ 1 more variable: petal.width <dbl>
> 
> # A purrr-style formula
> iris %>%
+   group_by(Species) %>%
+   summarise(across(starts_with("Sepal"), ~ mean(.x, na.rm = TRUE)))
# A tibble: 3 × 3
  Species    Sepal.Length Sepal.Width
  <fct>             <dbl>       <dbl>
1 setosa             5.01        3.43
2 versicolor         5.94        2.77
3 virginica          6.59        2.97
> 
> # A named list of functions
> iris %>%
+   group_by(Species) %>%
+   summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd)))
# A tibble: 3 × 5
  Species    Sepal.Length_mean Sepal.Length_sd Sepal.Width_mean Sepal.Width_sd
  <fct>                  <dbl>           <dbl>            <dbl>          <dbl>
1 setosa                  5.01           0.352             3.43          0.379
2 versicolor              5.94           0.516             2.77          0.314
3 virginica               6.59           0.636             2.97          0.322
> 
> # Use the .names argument to control the output names
> iris %>%
+   group_by(Species) %>%
+   summarise(across(starts_with("Sepal"), mean, .names = "mean_{.col}"))
# A tibble: 3 × 3
  Species    mean_Sepal.Length mean_Sepal.Width
  <fct>                  <dbl>            <dbl>
1 setosa                  5.01             3.43
2 versicolor              5.94             2.77
3 virginica               6.59             2.97
> iris %>%
+   group_by(Species) %>%
+   summarise(across(starts_with("Sepal"), list(mean = mean, sd = sd), .names = "{.col}.{.fn}"))
# A tibble: 3 × 5
  Species    Sepal.Length.mean Sepal.Length.sd Sepal.Width.mean Sepal.Width.sd
  <fct>                  <dbl>           <dbl>            <dbl>          <dbl>
1 setosa                  5.01           0.352             3.43          0.379
2 versicolor              5.94           0.516             2.77          0.314
3 virginica               6.59           0.636             2.97          0.322
> 
> # If a named external vector is used for column selection, .names will use
> # those names when constructing the output names
> iris %>%
+   group_by(Species) %>%
+   summarise(across(all_of(cols), mean, .names = "mean_{.col}"))
# A tibble: 3 × 3
  Species    mean_sepal.length mean_petal.width
  <fct>                  <dbl>            <dbl>
1 setosa                  5.01            0.246
2 versicolor              5.94            1.33 
3 virginica               6.59            2.03 
> 
> # When the list is not named, .fn is replaced by the function's position
> iris %>%
+   group_by(Species) %>%
+   summarise(across(starts_with("Sepal"), list(mean, sd), .names = "{.col}.fn{.fn}"))
# A tibble: 3 × 5
  Species    Sepal.Length.fn1 Sepal.Length.fn2 Sepal.Width.fn1 Sepal.Width.fn2
  <fct>                 <dbl>            <dbl>           <dbl>           <dbl>
1 setosa                 5.01            0.352            3.43           0.379
2 versicolor             5.94            0.516            2.77           0.314
3 virginica              6.59            0.636            2.97           0.322
> 
> # When the functions in .fns return a data frame, you typically get a
> # "packed" data frame back
> quantile_df <- function(x, probs = c(0.25, 0.5, 0.75)) {
+   tibble(quantile = probs, value = quantile(x, probs))
+ }
> 
> iris %>%
+   reframe(across(starts_with("Sepal"), quantile_df))
# A tibble: 3 × 2
  Sepal.Length$quantile $value Sepal.Width$quantile $value
                  <dbl>  <dbl>                <dbl>  <dbl>
1                  0.25    5.1                 0.25    2.8
2                  0.5     5.8                 0.5     3  
3                  0.75    6.4                 0.75    3.3
> 
> # Use .unpack to automatically expand these packed data frames into their
> # individual columns
> iris %>%
+   reframe(across(starts_with("Sepal"), quantile_df, .unpack = TRUE))
# A tibble: 3 × 4
  Sepal.Length_quantile Sepal.Length_value Sepal.Width_quantile
                  <dbl>              <dbl>                <dbl>
1                  0.25                5.1                 0.25
2                  0.5                 5.8                 0.5 
3                  0.75                6.4                 0.75
# ℹ 1 more variable: Sepal.Width_value <dbl>
> 
> # .unpack can utilize a glue specification if you don't like the defaults
> iris %>%
+   reframe(across(starts_with("Sepal"), quantile_df, .unpack = "{outer}.{inner}"))
# A tibble: 3 × 4
  Sepal.Length.quantile Sepal.Length.value Sepal.Width.quantile
                  <dbl>              <dbl>                <dbl>
1                  0.25                5.1                 0.25
2                  0.5                 5.8                 0.5 
3                  0.75                6.4                 0.75
# ℹ 1 more variable: Sepal.Width.value <dbl>
> 
> # This is also useful inside mutate(), for example, with a multi-lag helper
> multilag <- function(x, lags = 1:3) {
+   names(lags) <- as.character(lags)
+   purrr::map_dfr(lags, lag, x = x)
+ }
> 
> iris %>%
+   group_by(Species) %>%
+   mutate(across(starts_with("Sepal"), multilag, .unpack = TRUE)) %>%
+   select(Species, starts_with("Sepal"))
# A tibble: 150 × 9
# Groups:   Species [3]
   Species Sepal.Length Sepal.Width Sepal.Length_1 Sepal.Length_2 Sepal.Length_3
   <fct>          <dbl>       <dbl>          <dbl>          <dbl>          <dbl>
 1 setosa           5.1         3.5           NA             NA             NA  
 2 setosa           4.9         3              5.1           NA             NA  
 3 setosa           4.7         3.2            4.9            5.1           NA  
 4 setosa           4.6         3.1            4.7            4.9            5.1
 5 setosa           5           3.6            4.6            4.7            4.9
 6 setosa           5.4         3.9            5              4.6            4.7
 7 setosa           4.6         3.4            5.4            5              4.6
 8 setosa           5           3.4            4.6            5.4            5  
 9 setosa           4.4         2.9            5              4.6            5.4
10 setosa           4.9         3.1            4.4            5              4.6
# ℹ 140 more rows
# ℹ 3 more variables: Sepal.Width_1 <dbl>, Sepal.Width_2 <dbl>,
#   Sepal.Width_3 <dbl>
> 
> # if_any() and if_all() ----------------------------------------------------
> iris %>%
+   filter(if_any(ends_with("Width"), ~ . > 4))
# A tibble: 3 × 5
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
         <dbl>       <dbl>        <dbl>       <dbl> <fct>  
1          5.7         4.4          1.5         0.4 setosa 
2          5.2         4.1          1.5         0.1 setosa 
3          5.5         4.2          1.4         0.2 setosa 
> iris %>%
+   filter(if_all(ends_with("Width"), ~ . > 2))
# A tibble: 23 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species  
          <dbl>       <dbl>        <dbl>       <dbl> <fct>    
 1          6.3         3.3          6           2.5 virginica
 2          7.1         3            5.9         2.1 virginica
 3          6.5         3            5.8         2.2 virginica
 4          7.6         3            6.6         2.1 virginica
 5          7.2         3.6          6.1         2.5 virginica
 6          6.8         3            5.5         2.1 virginica
 7          5.8         2.8          5.1         2.4 virginica
 8          6.4         3.2          5.3         2.3 virginica
 9          7.7         3.8          6.7         2.2 virginica
10          7.7         2.6          6.9         2.3 virginica
# ℹ 13 more rows
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("across", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("all_equal")
> ### * all_equal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: all_equal
> ### Title: Flexible equality comparison for data frames
> ### Aliases: all_equal
> ### Keywords: internal
> 
> ### ** Examples
> 
> scramble <- function(x) x[sample(nrow(x)), sample(ncol(x))]
> 
> # `all_equal()` ignored row and column ordering by default,
> # but we now feel that that makes it too easy to make mistakes
> mtcars2 <- scramble(mtcars)
> all_equal(mtcars, mtcars2)
Warning: `all_equal()` was deprecated in dplyr 1.1.0.
ℹ Please use `all.equal()` instead.
ℹ And manually order the rows/cols as needed
[1] TRUE
> 
> # Instead, be explicit about the row and column ordering
> all.equal(
+   mtcars,
+   mtcars2[rownames(mtcars), names(mtcars)]
+ )
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("all_equal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("arrange")
> ### * arrange
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: arrange
> ### Title: Order rows using column values
> ### Aliases: arrange arrange.data.frame
> 
> ### ** Examples
> 
> arrange(mtcars, cyl, disp)
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
> arrange(mtcars, desc(disp))
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
> 
> # grouped arrange ignores groups
> by_cyl <- mtcars %>% group_by(cyl)
> by_cyl %>% arrange(desc(wt))
# A tibble: 32 × 11
# Groups:   cyl [3]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  10.4     8  460    215  3     5.42  17.8     0     0     3     4
 2  14.7     8  440    230  3.23  5.34  17.4     0     0     3     4
 3  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4
 4  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3
 5  19.2     8  400    175  3.08  3.84  17.0     0     0     3     2
 6  13.3     8  350    245  3.73  3.84  15.4     0     0     3     4
 7  15.2     8  276.   180  3.07  3.78  18       0     0     3     3
 8  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3
 9  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
10  15       8  301    335  3.54  3.57  14.6     0     1     5     8
# ℹ 22 more rows
> # Unless you specifically ask:
> by_cyl %>% arrange(desc(wt), .by_group = TRUE)
# A tibble: 32 × 11
# Groups:   cyl [3]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  24.4     4 147.     62  3.69  3.19  20       1     0     4     2
 2  22.8     4 141.     95  3.92  3.15  22.9     1     0     4     2
 3  21.4     4 121     109  4.11  2.78  18.6     1     1     4     2
 4  21.5     4 120.     97  3.7   2.46  20.0     1     0     3     1
 5  22.8     4 108      93  3.85  2.32  18.6     1     1     4     1
 6  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1
 7  26       4 120.     91  4.43  2.14  16.7     0     1     5     2
 8  27.3     4  79      66  4.08  1.94  18.9     1     1     4     1
 9  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1
10  30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2
# ℹ 22 more rows
> 
> # use embracing when wrapping in a function;
> # see ?rlang::args_data_masking for more details
> tidy_eval_arrange <- function(.data, var) {
+   .data %>%
+     arrange({{ var }})
+ }
> tidy_eval_arrange(mtcars, mpg)
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
> 
> # Use `across()` or `pick()` to select columns with tidy-select
> iris %>% arrange(pick(starts_with("Sepal")))
    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
1            4.3         3.0          1.1         0.1     setosa
2            4.4         2.9          1.4         0.2     setosa
3            4.4         3.0          1.3         0.2     setosa
4            4.4         3.2          1.3         0.2     setosa
5            4.5         2.3          1.3         0.3     setosa
6            4.6         3.1          1.5         0.2     setosa
7            4.6         3.2          1.4         0.2     setosa
8            4.6         3.4          1.4         0.3     setosa
9            4.6         3.6          1.0         0.2     setosa
10           4.7         3.2          1.3         0.2     setosa
11           4.7         3.2          1.6         0.2     setosa
12           4.8         3.0          1.4         0.1     setosa
13           4.8         3.0          1.4         0.3     setosa
14           4.8         3.1          1.6         0.2     setosa
15           4.8         3.4          1.6         0.2     setosa
16           4.8         3.4          1.9         0.2     setosa
17           4.9         2.4          3.3         1.0 versicolor
18           4.9         2.5          4.5         1.7  virginica
19           4.9         3.0          1.4         0.2     setosa
20           4.9         3.1          1.5         0.1     setosa
21           4.9         3.1          1.5         0.2     setosa
22           4.9         3.6          1.4         0.1     setosa
23           5.0         2.0          3.5         1.0 versicolor
24           5.0         2.3          3.3         1.0 versicolor
25           5.0         3.0          1.6         0.2     setosa
26           5.0         3.2          1.2         0.2     setosa
27           5.0         3.3          1.4         0.2     setosa
28           5.0         3.4          1.5         0.2     setosa
29           5.0         3.4          1.6         0.4     setosa
30           5.0         3.5          1.3         0.3     setosa
31           5.0         3.5          1.6         0.6     setosa
32           5.0         3.6          1.4         0.2     setosa
33           5.1         2.5          3.0         1.1 versicolor
34           5.1         3.3          1.7         0.5     setosa
35           5.1         3.4          1.5         0.2     setosa
36           5.1         3.5          1.4         0.2     setosa
37           5.1         3.5          1.4         0.3     setosa
38           5.1         3.7          1.5         0.4     setosa
39           5.1         3.8          1.5         0.3     setosa
40           5.1         3.8          1.9         0.4     setosa
41           5.1         3.8          1.6         0.2     setosa
42           5.2         2.7          3.9         1.4 versicolor
43           5.2         3.4          1.4         0.2     setosa
44           5.2         3.5          1.5         0.2     setosa
45           5.2         4.1          1.5         0.1     setosa
46           5.3         3.7          1.5         0.2     setosa
47           5.4         3.0          4.5         1.5 versicolor
48           5.4         3.4          1.7         0.2     setosa
49           5.4         3.4          1.5         0.4     setosa
50           5.4         3.7          1.5         0.2     setosa
51           5.4         3.9          1.7         0.4     setosa
52           5.4         3.9          1.3         0.4     setosa
53           5.5         2.3          4.0         1.3 versicolor
54           5.5         2.4          3.8         1.1 versicolor
55           5.5         2.4          3.7         1.0 versicolor
56           5.5         2.5          4.0         1.3 versicolor
57           5.5         2.6          4.4         1.2 versicolor
58           5.5         3.5          1.3         0.2     setosa
59           5.5         4.2          1.4         0.2     setosa
60           5.6         2.5          3.9         1.1 versicolor
61           5.6         2.7          4.2         1.3 versicolor
62           5.6         2.8          4.9         2.0  virginica
63           5.6         2.9          3.6         1.3 versicolor
64           5.6         3.0          4.5         1.5 versicolor
65           5.6         3.0          4.1         1.3 versicolor
66           5.7         2.5          5.0         2.0  virginica
67           5.7         2.6          3.5         1.0 versicolor
68           5.7         2.8          4.5         1.3 versicolor
69           5.7         2.8          4.1         1.3 versicolor
70           5.7         2.9          4.2         1.3 versicolor
71           5.7         3.0          4.2         1.2 versicolor
72           5.7         3.8          1.7         0.3     setosa
73           5.7         4.4          1.5         0.4     setosa
74           5.8         2.6          4.0         1.2 versicolor
75           5.8         2.7          4.1         1.0 versicolor
76           5.8         2.7          3.9         1.2 versicolor
77           5.8         2.7          5.1         1.9  virginica
78           5.8         2.7          5.1         1.9  virginica
79           5.8         2.8          5.1         2.4  virginica
80           5.8         4.0          1.2         0.2     setosa
81           5.9         3.0          4.2         1.5 versicolor
82           5.9         3.0          5.1         1.8  virginica
83           5.9         3.2          4.8         1.8 versicolor
84           6.0         2.2          4.0         1.0 versicolor
85           6.0         2.2          5.0         1.5  virginica
86           6.0         2.7          5.1         1.6 versicolor
87           6.0         2.9          4.5         1.5 versicolor
88           6.0         3.0          4.8         1.8  virginica
89           6.0         3.4          4.5         1.6 versicolor
90           6.1         2.6          5.6         1.4  virginica
91           6.1         2.8          4.0         1.3 versicolor
92           6.1         2.8          4.7         1.2 versicolor
93           6.1         2.9          4.7         1.4 versicolor
94           6.1         3.0          4.6         1.4 versicolor
95           6.1         3.0          4.9         1.8  virginica
96           6.2         2.2          4.5         1.5 versicolor
97           6.2         2.8          4.8         1.8  virginica
98           6.2         2.9          4.3         1.3 versicolor
99           6.2         3.4          5.4         2.3  virginica
100          6.3         2.3          4.4         1.3 versicolor
101          6.3         2.5          4.9         1.5 versicolor
102          6.3         2.5          5.0         1.9  virginica
103          6.3         2.7          4.9         1.8  virginica
104          6.3         2.8          5.1         1.5  virginica
105          6.3         2.9          5.6         1.8  virginica
106          6.3         3.3          4.7         1.6 versicolor
107          6.3         3.3          6.0         2.5  virginica
108          6.3         3.4          5.6         2.4  virginica
109          6.4         2.7          5.3         1.9  virginica
110          6.4         2.8          5.6         2.1  virginica
111          6.4         2.8          5.6         2.2  virginica
112          6.4         2.9          4.3         1.3 versicolor
113          6.4         3.1          5.5         1.8  virginica
114          6.4         3.2          4.5         1.5 versicolor
115          6.4         3.2          5.3         2.3  virginica
116          6.5         2.8          4.6         1.5 versicolor
117          6.5         3.0          5.8         2.2  virginica
118          6.5         3.0          5.5         1.8  virginica
119          6.5         3.0          5.2         2.0  virginica
120          6.5         3.2          5.1         2.0  virginica
121          6.6         2.9          4.6         1.3 versicolor
122          6.6         3.0          4.4         1.4 versicolor
123          6.7         2.5          5.8         1.8  virginica
124          6.7         3.0          5.0         1.7 versicolor
125          6.7         3.0          5.2         2.3  virginica
126          6.7         3.1          4.4         1.4 versicolor
127          6.7         3.1          4.7         1.5 versicolor
128          6.7         3.1          5.6         2.4  virginica
129          6.7         3.3          5.7         2.1  virginica
130          6.7         3.3          5.7         2.5  virginica
131          6.8         2.8          4.8         1.4 versicolor
132          6.8         3.0          5.5         2.1  virginica
133          6.8         3.2          5.9         2.3  virginica
134          6.9         3.1          4.9         1.5 versicolor
135          6.9         3.1          5.4         2.1  virginica
136          6.9         3.1          5.1         2.3  virginica
137          6.9         3.2          5.7         2.3  virginica
138          7.0         3.2          4.7         1.4 versicolor
139          7.1         3.0          5.9         2.1  virginica
140          7.2         3.0          5.8         1.6  virginica
141          7.2         3.2          6.0         1.8  virginica
142          7.2         3.6          6.1         2.5  virginica
143          7.3         2.9          6.3         1.8  virginica
144          7.4         2.8          6.1         1.9  virginica
145          7.6         3.0          6.6         2.1  virginica
146          7.7         2.6          6.9         2.3  virginica
147          7.7         2.8          6.7         2.0  virginica
148          7.7         3.0          6.1         2.3  virginica
149          7.7         3.8          6.7         2.2  virginica
150          7.9         3.8          6.4         2.0  virginica
> iris %>% arrange(across(starts_with("Sepal"), desc))
    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
1            7.9         3.8          6.4         2.0  virginica
2            7.7         3.8          6.7         2.2  virginica
3            7.7         3.0          6.1         2.3  virginica
4            7.7         2.8          6.7         2.0  virginica
5            7.7         2.6          6.9         2.3  virginica
6            7.6         3.0          6.6         2.1  virginica
7            7.4         2.8          6.1         1.9  virginica
8            7.3         2.9          6.3         1.8  virginica
9            7.2         3.6          6.1         2.5  virginica
10           7.2         3.2          6.0         1.8  virginica
11           7.2         3.0          5.8         1.6  virginica
12           7.1         3.0          5.9         2.1  virginica
13           7.0         3.2          4.7         1.4 versicolor
14           6.9         3.2          5.7         2.3  virginica
15           6.9         3.1          4.9         1.5 versicolor
16           6.9         3.1          5.4         2.1  virginica
17           6.9         3.1          5.1         2.3  virginica
18           6.8         3.2          5.9         2.3  virginica
19           6.8         3.0          5.5         2.1  virginica
20           6.8         2.8          4.8         1.4 versicolor
21           6.7         3.3          5.7         2.1  virginica
22           6.7         3.3          5.7         2.5  virginica
23           6.7         3.1          4.4         1.4 versicolor
24           6.7         3.1          4.7         1.5 versicolor
25           6.7         3.1          5.6         2.4  virginica
26           6.7         3.0          5.0         1.7 versicolor
27           6.7         3.0          5.2         2.3  virginica
28           6.7         2.5          5.8         1.8  virginica
29           6.6         3.0          4.4         1.4 versicolor
30           6.6         2.9          4.6         1.3 versicolor
31           6.5         3.2          5.1         2.0  virginica
32           6.5         3.0          5.8         2.2  virginica
33           6.5         3.0          5.5         1.8  virginica
34           6.5         3.0          5.2         2.0  virginica
35           6.5         2.8          4.6         1.5 versicolor
36           6.4         3.2          4.5         1.5 versicolor
37           6.4         3.2          5.3         2.3  virginica
38           6.4         3.1          5.5         1.8  virginica
39           6.4         2.9          4.3         1.3 versicolor
40           6.4         2.8          5.6         2.1  virginica
41           6.4         2.8          5.6         2.2  virginica
42           6.4         2.7          5.3         1.9  virginica
43           6.3         3.4          5.6         2.4  virginica
44           6.3         3.3          4.7         1.6 versicolor
45           6.3         3.3          6.0         2.5  virginica
46           6.3         2.9          5.6         1.8  virginica
47           6.3         2.8          5.1         1.5  virginica
48           6.3         2.7          4.9         1.8  virginica
49           6.3         2.5          4.9         1.5 versicolor
50           6.3         2.5          5.0         1.9  virginica
51           6.3         2.3          4.4         1.3 versicolor
52           6.2         3.4          5.4         2.3  virginica
53           6.2         2.9          4.3         1.3 versicolor
54           6.2         2.8          4.8         1.8  virginica
55           6.2         2.2          4.5         1.5 versicolor
56           6.1         3.0          4.6         1.4 versicolor
57           6.1         3.0          4.9         1.8  virginica
58           6.1         2.9          4.7         1.4 versicolor
59           6.1         2.8          4.0         1.3 versicolor
60           6.1         2.8          4.7         1.2 versicolor
61           6.1         2.6          5.6         1.4  virginica
62           6.0         3.4          4.5         1.6 versicolor
63           6.0         3.0          4.8         1.8  virginica
64           6.0         2.9          4.5         1.5 versicolor
65           6.0         2.7          5.1         1.6 versicolor
66           6.0         2.2          4.0         1.0 versicolor
67           6.0         2.2          5.0         1.5  virginica
68           5.9         3.2          4.8         1.8 versicolor
69           5.9         3.0          4.2         1.5 versicolor
70           5.9         3.0          5.1         1.8  virginica
71           5.8         4.0          1.2         0.2     setosa
72           5.8         2.8          5.1         2.4  virginica
73           5.8         2.7          4.1         1.0 versicolor
74           5.8         2.7          3.9         1.2 versicolor
75           5.8         2.7          5.1         1.9  virginica
76           5.8         2.7          5.1         1.9  virginica
77           5.8         2.6          4.0         1.2 versicolor
78           5.7         4.4          1.5         0.4     setosa
79           5.7         3.8          1.7         0.3     setosa
80           5.7         3.0          4.2         1.2 versicolor
81           5.7         2.9          4.2         1.3 versicolor
82           5.7         2.8          4.5         1.3 versicolor
83           5.7         2.8          4.1         1.3 versicolor
84           5.7         2.6          3.5         1.0 versicolor
85           5.7         2.5          5.0         2.0  virginica
86           5.6         3.0          4.5         1.5 versicolor
87           5.6         3.0          4.1         1.3 versicolor
88           5.6         2.9          3.6         1.3 versicolor
89           5.6         2.8          4.9         2.0  virginica
90           5.6         2.7          4.2         1.3 versicolor
91           5.6         2.5          3.9         1.1 versicolor
92           5.5         4.2          1.4         0.2     setosa
93           5.5         3.5          1.3         0.2     setosa
94           5.5         2.6          4.4         1.2 versicolor
95           5.5         2.5          4.0         1.3 versicolor
96           5.5         2.4          3.8         1.1 versicolor
97           5.5         2.4          3.7         1.0 versicolor
98           5.5         2.3          4.0         1.3 versicolor
99           5.4         3.9          1.7         0.4     setosa
100          5.4         3.9          1.3         0.4     setosa
101          5.4         3.7          1.5         0.2     setosa
102          5.4         3.4          1.7         0.2     setosa
103          5.4         3.4          1.5         0.4     setosa
104          5.4         3.0          4.5         1.5 versicolor
105          5.3         3.7          1.5         0.2     setosa
106          5.2         4.1          1.5         0.1     setosa
107          5.2         3.5          1.5         0.2     setosa
108          5.2         3.4          1.4         0.2     setosa
109          5.2         2.7          3.9         1.4 versicolor
110          5.1         3.8          1.5         0.3     setosa
111          5.1         3.8          1.9         0.4     setosa
112          5.1         3.8          1.6         0.2     setosa
113          5.1         3.7          1.5         0.4     setosa
114          5.1         3.5          1.4         0.2     setosa
115          5.1         3.5          1.4         0.3     setosa
116          5.1         3.4          1.5         0.2     setosa
117          5.1         3.3          1.7         0.5     setosa
118          5.1         2.5          3.0         1.1 versicolor
119          5.0         3.6          1.4         0.2     setosa
120          5.0         3.5          1.3         0.3     setosa
121          5.0         3.5          1.6         0.6     setosa
122          5.0         3.4          1.5         0.2     setosa
123          5.0         3.4          1.6         0.4     setosa
124          5.0         3.3          1.4         0.2     setosa
125          5.0         3.2          1.2         0.2     setosa
126          5.0         3.0          1.6         0.2     setosa
127          5.0         2.3          3.3         1.0 versicolor
128          5.0         2.0          3.5         1.0 versicolor
129          4.9         3.6          1.4         0.1     setosa
130          4.9         3.1          1.5         0.1     setosa
131          4.9         3.1          1.5         0.2     setosa
132          4.9         3.0          1.4         0.2     setosa
133          4.9         2.5          4.5         1.7  virginica
134          4.9         2.4          3.3         1.0 versicolor
135          4.8         3.4          1.6         0.2     setosa
136          4.8         3.4          1.9         0.2     setosa
137          4.8         3.1          1.6         0.2     setosa
138          4.8         3.0          1.4         0.1     setosa
139          4.8         3.0          1.4         0.3     setosa
140          4.7         3.2          1.3         0.2     setosa
141          4.7         3.2          1.6         0.2     setosa
142          4.6         3.6          1.0         0.2     setosa
143          4.6         3.4          1.4         0.3     setosa
144          4.6         3.2          1.4         0.2     setosa
145          4.6         3.1          1.5         0.2     setosa
146          4.5         2.3          1.3         0.3     setosa
147          4.4         3.2          1.3         0.2     setosa
148          4.4         3.0          1.3         0.2     setosa
149          4.4         2.9          1.4         0.2     setosa
150          4.3         3.0          1.1         0.1     setosa
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("arrange", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("arrange_all")
> ### * arrange_all
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: arrange_all
> ### Title: Arrange rows by a selection of variables
> ### Aliases: arrange_all arrange_at arrange_if
> ### Keywords: internal
> 
> ### ** Examples
> 
> df <- as_tibble(mtcars)
> arrange_all(df)
# A tibble: 32 × 11
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  10.4     8  460    215  3     5.42  17.8     0     0     3     4
 2  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4
 3  13.3     8  350    245  3.73  3.84  15.4     0     0     3     4
 4  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 5  14.7     8  440    230  3.23  5.34  17.4     0     0     3     4
 6  15       8  301    335  3.54  3.57  14.6     0     1     5     8
 7  15.2     8  276.   180  3.07  3.78  18       0     0     3     3
 8  15.2     8  304    150  3.15  3.44  17.3     0     0     3     2
 9  15.5     8  318    150  2.76  3.52  16.9     0     0     3     2
10  15.8     8  351    264  4.22  3.17  14.5     0     1     5     4
# ℹ 22 more rows
> # ->
> arrange(df, pick(everything()))
# A tibble: 32 × 11
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  10.4     8  460    215  3     5.42  17.8     0     0     3     4
 2  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4
 3  13.3     8  350    245  3.73  3.84  15.4     0     0     3     4
 4  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 5  14.7     8  440    230  3.23  5.34  17.4     0     0     3     4
 6  15       8  301    335  3.54  3.57  14.6     0     1     5     8
 7  15.2     8  276.   180  3.07  3.78  18       0     0     3     3
 8  15.2     8  304    150  3.15  3.44  17.3     0     0     3     2
 9  15.5     8  318    150  2.76  3.52  16.9     0     0     3     2
10  15.8     8  351    264  4.22  3.17  14.5     0     1     5     4
# ℹ 22 more rows
> 
> arrange_all(df, desc)
# A tibble: 32 × 11
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1
 2  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1
 3  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2
 4  30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2
 5  27.3     4  79      66  4.08  1.94  18.9     1     1     4     1
 6  26       4 120.     91  4.43  2.14  16.7     0     1     5     2
 7  24.4     4 147.     62  3.69  3.19  20       1     0     4     2
 8  22.8     4 141.     95  3.92  3.15  22.9     1     0     4     2
 9  22.8     4 108      93  3.85  2.32  18.6     1     1     4     1
10  21.5     4 120.     97  3.7   2.46  20.0     1     0     3     1
# ℹ 22 more rows
> # ->
> arrange(df, across(everything(), desc))
# A tibble: 32 × 11
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  33.9     4  71.1    65  4.22  1.84  19.9     1     1     4     1
 2  32.4     4  78.7    66  4.08  2.2   19.5     1     1     4     1
 3  30.4     4  95.1   113  3.77  1.51  16.9     1     1     5     2
 4  30.4     4  75.7    52  4.93  1.62  18.5     1     1     4     2
 5  27.3     4  79      66  4.08  1.94  18.9     1     1     4     1
 6  26       4 120.     91  4.43  2.14  16.7     0     1     5     2
 7  24.4     4 147.     62  3.69  3.19  20       1     0     4     2
 8  22.8     4 141.     95  3.92  3.15  22.9     1     0     4     2
 9  22.8     4 108      93  3.85  2.32  18.6     1     1     4     1
10  21.5     4 120.     97  3.7   2.46  20.0     1     0     3     1
# ℹ 22 more rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("arrange_all", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("band_members")
> ### * band_members
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: band_members
> ### Title: Band membership
> ### Aliases: band_members band_instruments band_instruments2
> ### Keywords: datasets
> 
> ### ** Examples
> 
> band_members
# A tibble: 3 × 2
  name  band   
  <chr> <chr>  
1 Mick  Stones 
2 John  Beatles
3 Paul  Beatles
> band_instruments
# A tibble: 3 × 2
  name  plays 
  <chr> <chr> 
1 John  guitar
2 Paul  bass  
3 Keith guitar
> band_instruments2
# A tibble: 3 × 2
  artist plays 
  <chr>  <chr> 
1 John   guitar
2 Paul   bass  
3 Keith  guitar
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("band_members", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("between")
> ### * between
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: between
> ### Title: Detect where values fall in a specified range
> ### Aliases: between
> 
> ### ** Examples
> 
> between(1:12, 7, 9)
 [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE
> 
> x <- rnorm(1e2)
> x[between(x, -1, 1)]
 [1] -0.626453811  0.183643324 -0.835628612  0.329507772 -0.820468384
 [6]  0.487429052  0.738324705  0.575781352 -0.305388387  0.389843236
[11] -0.621240581 -0.044933609 -0.016190263  0.943836211  0.821221195
[16]  0.593901321  0.918977372  0.782136301  0.074564983  0.619825748
[21] -0.056128740 -0.155795507 -0.478150055  0.417941560 -0.102787727
[26]  0.387671612 -0.053805041 -0.414994563 -0.394289954 -0.059313397
[31]  0.763175748 -0.164523596 -0.253361680  0.696963375  0.556663199
[36] -0.688755695 -0.707495157  0.364581962  0.768532925 -0.112346212
[41]  0.881107726  0.398105880 -0.612026393  0.341119691 -0.367221476
[46]  0.569719627 -0.135054604 -0.039240003  0.689739362  0.028002159
[51] -0.743273209  0.188792300  0.153253338  0.475509529 -0.709946431
[56]  0.610726353 -0.934097632  0.291446236 -0.443291873  0.001105352
[61]  0.074341324 -0.589520946 -0.568668733 -0.135178615  0.593946188
[66]  0.332950371 -0.304183924  0.370018810  0.267098791 -0.542520031
[71]  0.700213650  0.558486426 -0.573265414 -0.473400636
> 
> # On a tibble using `filter()`
> filter(starwars, between(height, 100, 150))
# A tibble: 5 × 14
  name      height  mass hair_color skin_color eye_color birth_year sex   gender
  <chr>      <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
1 Leia Org…    150    49 brown      light      brown             19 fema… femin…
2 Mon Moth…    150    NA auburn     fair       blue              48 fema… femin…
3 Watto        137    NA black      blue, grey yellow            NA male  mascu…
4 Sebulba      112    40 none       grey, red  orange            NA male  mascu…
5 Gasgano      122    NA none       white, bl… black             NA male  mascu…
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("between", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("bind_cols")
> ### * bind_cols
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: bind_cols
> ### Title: Bind multiple data frames by column
> ### Aliases: bind_cols
> 
> ### ** Examples
> 
> df1 <- tibble(x = 1:3)
> df2 <- tibble(y = 3:1)
> bind_cols(df1, df2)
# A tibble: 3 × 2
      x     y
  <int> <int>
1     1     3
2     2     2
3     3     1
> 
> # Row sizes must be compatible when column-binding
> try(bind_cols(tibble(x = 1:3), tibble(y = 1:2)))
Error in bind_cols(tibble(x = 1:3), tibble(y = 1:2)) : 
  Can't recycle `..1` (size 3) to match `..2` (size 2).
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("bind_cols", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("bind_rows")
> ### * bind_rows
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: bind_rows
> ### Title: Bind multiple data frames by row
> ### Aliases: bind_rows bind
> 
> ### ** Examples
> 
> df1 <- tibble(x = 1:2, y = letters[1:2])
> df2 <- tibble(x = 4:5, z = 1:2)
> 
> # You can supply individual data frames as arguments:
> bind_rows(df1, df2)
# A tibble: 4 × 3
      x y         z
  <int> <chr> <int>
1     1 a        NA
2     2 b        NA
3     4 <NA>      1
4     5 <NA>      2
> 
> # Or a list of data frames:
> bind_rows(list(df1, df2))
# A tibble: 4 × 3
      x y         z
  <int> <chr> <int>
1     1 a        NA
2     2 b        NA
3     4 <NA>      1
4     5 <NA>      2
> 
> # When you supply a column name with the `.id` argument, a new
> # column is created to link each row to its original data frame
> bind_rows(list(df1, df2), .id = "id")
# A tibble: 4 × 4
  id        x y         z
  <chr> <int> <chr> <int>
1 1         1 a        NA
2 1         2 b        NA
3 2         4 <NA>      1
4 2         5 <NA>      2
> bind_rows(list(a = df1, b = df2), .id = "id")
# A tibble: 4 × 4
  id        x y         z
  <chr> <int> <chr> <int>
1 a         1 a        NA
2 a         2 b        NA
3 b         4 <NA>      1
4 b         5 <NA>      2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("bind_rows", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("c_across")
> ### * c_across
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: c_across
> ### Title: Combine values from multiple columns
> ### Aliases: c_across
> 
> ### ** Examples
> 
> df <- tibble(id = 1:4, w = runif(4), x = runif(4), y = runif(4), z = runif(4))
> df %>%
+   rowwise() %>%
+   mutate(
+     sum = sum(c_across(w:z)),
+     sd = sd(c_across(w:z))
+   )
# A tibble: 4 × 7
# Rowwise: 
     id     w     x      y     z   sum    sd
  <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl>
1     1 0.266 0.202 0.629  0.687  1.78 0.248
2     2 0.372 0.898 0.0618 0.384  1.72 0.347
3     3 0.573 0.945 0.206  0.770  2.49 0.317
4     4 0.908 0.661 0.177  0.498  2.24 0.307
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("c_across", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("case_match")
> ### * case_match
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: case_match
> ### Title: A general vectorised 'switch()'
> ### Aliases: case_match
> 
> ### ** Examples
> 
> x <- c("a", "b", "a", "d", "b", NA, "c", "e")
> 
> # `case_match()` acts like a vectorized `switch()`.
> # Unmatched values "fall through" as a missing value.
> case_match(
+   x,
+   "a" ~ 1,
+   "b" ~ 2,
+   "c" ~ 3,
+   "d" ~ 4
+ )
[1]  1  2  1  4  2 NA  3 NA
> 
> # Missing values can be matched exactly, and `.default` can be used to
> # control the value used for unmatched values of `.x`
> case_match(
+   x,
+   "a" ~ 1,
+   "b" ~ 2,
+   "c" ~ 3,
+   "d" ~ 4,
+   NA ~ 0,
+   .default = 100
+ )
[1]   1   2   1   4   2   0   3 100
> 
> # Input values can be grouped into the same expression to map them to the
> # same output value
> case_match(
+   x,
+   c("a", "b") ~ "low",
+   c("c", "d", "e") ~ "high"
+ )
[1] "low"  "low"  "low"  "high" "low"  NA     "high" "high"
> 
> # `case_match()` isn't limited to character input:
> y <- c(1, 2, 1, 3, 1, NA, 2, 4)
> 
> case_match(
+   y,
+   c(1, 3) ~ "odd",
+   c(2, 4) ~ "even",
+   .default = "missing"
+ )
[1] "odd"     "even"    "odd"     "odd"     "odd"     "missing" "even"   
[8] "even"   
> 
> # Setting `.default` to the original vector is a useful way to replace
> # selected values, leaving everything else as is
> case_match(y, NA ~ 0, .default = y)
[1] 1 2 1 3 1 0 2 4
> 
> starwars %>%
+   mutate(
+     # Replace missings, but leave everything else alone
+     hair_color = case_match(hair_color, NA ~ "unknown", .default = hair_color),
+     # Replace some, but not all, of the species
+     species = case_match(
+       species,
+       "Human" ~ "Humanoid",
+       "Droid" ~ "Robot",
+       c("Wookiee", "Ewok") ~ "Hairy",
+       .default = species
+     ),
+     .keep = "used"
+   )
# A tibble: 87 × 2
   hair_color    species 
   <chr>         <chr>   
 1 blond         Humanoid
 2 unknown       Robot   
 3 unknown       Robot   
 4 none          Humanoid
 5 brown         Humanoid
 6 brown, grey   Humanoid
 7 brown         Humanoid
 8 unknown       Robot   
 9 black         Humanoid
10 auburn, white Humanoid
# ℹ 77 more rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("case_match", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("case_when")
> ### * case_when
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: case_when
> ### Title: A general vectorised if-else
> ### Aliases: case_when
> 
> ### ** Examples
> 
> x <- 1:70
> case_when(
+   x %% 35 == 0 ~ "fizz buzz",
+   x %% 5 == 0 ~ "fizz",
+   x %% 7 == 0 ~ "buzz",
+   .default = as.character(x)
+ )
 [1] "1"         "2"         "3"         "4"         "fizz"      "6"        
 [7] "buzz"      "8"         "9"         "fizz"      "11"        "12"       
[13] "13"        "buzz"      "fizz"      "16"        "17"        "18"       
[19] "19"        "fizz"      "buzz"      "22"        "23"        "24"       
[25] "fizz"      "26"        "27"        "buzz"      "29"        "fizz"     
[31] "31"        "32"        "33"        "34"        "fizz buzz" "36"       
[37] "37"        "38"        "39"        "fizz"      "41"        "buzz"     
[43] "43"        "44"        "fizz"      "46"        "47"        "48"       
[49] "buzz"      "fizz"      "51"        "52"        "53"        "54"       
[55] "fizz"      "buzz"      "57"        "58"        "59"        "fizz"     
[61] "61"        "62"        "buzz"      "64"        "fizz"      "66"       
[67] "67"        "68"        "69"        "fizz buzz"
> 
> # Like an if statement, the arguments are evaluated in order, so you must
> # proceed from the most specific to the most general. This won't work:
> case_when(
+   x %%  5 == 0 ~ "fizz",
+   x %%  7 == 0 ~ "buzz",
+   x %% 35 == 0 ~ "fizz buzz",
+   .default = as.character(x)
+ )
 [1] "1"    "2"    "3"    "4"    "fizz" "6"    "buzz" "8"    "9"    "fizz"
[11] "11"   "12"   "13"   "buzz" "fizz" "16"   "17"   "18"   "19"   "fizz"
[21] "buzz" "22"   "23"   "24"   "fizz" "26"   "27"   "buzz" "29"   "fizz"
[31] "31"   "32"   "33"   "34"   "fizz" "36"   "37"   "38"   "39"   "fizz"
[41] "41"   "buzz" "43"   "44"   "fizz" "46"   "47"   "48"   "buzz" "fizz"
[51] "51"   "52"   "53"   "54"   "fizz" "buzz" "57"   "58"   "59"   "fizz"
[61] "61"   "62"   "buzz" "64"   "fizz" "66"   "67"   "68"   "69"   "fizz"
> 
> # If none of the cases match and no `.default` is supplied, NA is used:
> case_when(
+   x %% 35 == 0 ~ "fizz buzz",
+   x %% 5 == 0 ~ "fizz",
+   x %% 7 == 0 ~ "buzz",
+ )
 [1] NA          NA          NA          NA          "fizz"      NA         
 [7] "buzz"      NA          NA          "fizz"      NA          NA         
[13] NA          "buzz"      "fizz"      NA          NA          NA         
[19] NA          "fizz"      "buzz"      NA          NA          NA         
[25] "fizz"      NA          NA          "buzz"      NA          "fizz"     
[31] NA          NA          NA          NA          "fizz buzz" NA         
[37] NA          NA          NA          "fizz"      NA          "buzz"     
[43] NA          NA          "fizz"      NA          NA          NA         
[49] "buzz"      "fizz"      NA          NA          NA          NA         
[55] "fizz"      "buzz"      NA          NA          NA          "fizz"     
[61] NA          NA          "buzz"      NA          "fizz"      NA         
[67] NA          NA          NA          "fizz buzz"
> 
> # Note that `NA` values on the LHS are treated like `FALSE` and will be
> # assigned the `.default` value. You must handle them explicitly if you
> # want to use a different value. The exact way to handle missing values is
> # dependent on the set of LHS conditions you use.
> x[2:4] <- NA_real_
> case_when(
+   x %% 35 == 0 ~ "fizz buzz",
+   x %% 5 == 0 ~ "fizz",
+   x %% 7 == 0 ~ "buzz",
+   is.na(x) ~ "nope",
+   .default = as.character(x)
+ )
 [1] "1"         "nope"      "nope"      "nope"      "fizz"      "6"        
 [7] "buzz"      "8"         "9"         "fizz"      "11"        "12"       
[13] "13"        "buzz"      "fizz"      "16"        "17"        "18"       
[19] "19"        "fizz"      "buzz"      "22"        "23"        "24"       
[25] "fizz"      "26"        "27"        "buzz"      "29"        "fizz"     
[31] "31"        "32"        "33"        "34"        "fizz buzz" "36"       
[37] "37"        "38"        "39"        "fizz"      "41"        "buzz"     
[43] "43"        "44"        "fizz"      "46"        "47"        "48"       
[49] "buzz"      "fizz"      "51"        "52"        "53"        "54"       
[55] "fizz"      "buzz"      "57"        "58"        "59"        "fizz"     
[61] "61"        "62"        "buzz"      "64"        "fizz"      "66"       
[67] "67"        "68"        "69"        "fizz buzz"
> 
> # `case_when()` evaluates all RHS expressions, and then constructs its
> # result by extracting the selected (via the LHS expressions) parts.
> # In particular `NaN`s are produced in this case:
> y <- seq(-2, 2, by = .5)
> case_when(
+   y >= 0 ~ sqrt(y),
+   .default = y
+ )
Warning in sqrt(y) : NaNs produced
[1] -2.0000000 -1.5000000 -1.0000000 -0.5000000  0.0000000  0.7071068  1.0000000
[8]  1.2247449  1.4142136
> 
> # `case_when()` is particularly useful inside `mutate()` when you want to
> # create a new variable that relies on a complex combination of existing
> # variables
> starwars %>%
+   select(name:mass, gender, species) %>%
+   mutate(
+     type = case_when(
+       height > 200 | mass > 200 ~ "large",
+       species == "Droid" ~ "robot",
+       .default = "other"
+     )
+   )
# A tibble: 87 × 6
   name               height  mass gender    species type 
   <chr>               <int> <dbl> <chr>     <chr>   <chr>
 1 Luke Skywalker        172    77 masculine Human   other
 2 C-3PO                 167    75 masculine Droid   robot
 3 R2-D2                  96    32 masculine Droid   robot
 4 Darth Vader           202   136 masculine Human   large
 5 Leia Organa           150    49 feminine  Human   other
 6 Owen Lars             178   120 masculine Human   other
 7 Beru Whitesun Lars    165    75 feminine  Human   other
 8 R5-D4                  97    32 masculine Droid   robot
 9 Biggs Darklighter     183    84 masculine Human   other
10 Obi-Wan Kenobi        182    77 masculine Human   other
# ℹ 77 more rows
> 
> 
> # `case_when()` is not a tidy eval function. If you'd like to reuse
> # the same patterns, extract the `case_when()` call in a normal
> # function:
> case_character_type <- function(height, mass, species) {
+   case_when(
+     height > 200 | mass > 200 ~ "large",
+     species == "Droid" ~ "robot",
+     .default = "other"
+   )
+ }
> 
> case_character_type(150, 250, "Droid")
[1] "large"
> case_character_type(150, 150, "Droid")
[1] "robot"
> 
> # Such functions can be used inside `mutate()` as well:
> starwars %>%
+   mutate(type = case_character_type(height, mass, species)) %>%
+   pull(type)
 [1] "other" "robot" "robot" "large" "other" "other" "other" "robot" "other"
[10] "other" "other" "other" "large" "other" "other" "large" "other" "other"
[19] "other" "other" "other" "robot" "other" "other" "other" "other" "other"
[28] "other" "other" "other" "other" "other" "other" "other" "other" "large"
[37] "large" "other" "other" "other" "other" "other" "other" "other" "other"
[46] "other" "other" "other" "other" "other" "other" "other" "other" "other"
[55] "other" "large" "other" "other" "other" "other" "other" "other" "other"
[64] "other" "other" "other" "other" "other" "other" "other" "large" "large"
[73] "other" "robot" "other" "other" "other" "large" "large" "other" "other"
[82] "large" "other" "other" "other" "robot" "other"
> 
> # `case_when()` ignores `NULL` inputs. This is useful when you'd
> # like to use a pattern only under certain conditions. Here we'll
> # take advantage of the fact that `if` returns `NULL` when there is
> # no `else` clause:
> case_character_type <- function(height, mass, species, robots = TRUE) {
+   case_when(
+     height > 200 | mass > 200 ~ "large",
+     if (robots) species == "Droid" ~ "robot",
+     .default = "other"
+   )
+ }
> 
> starwars %>%
+   mutate(type = case_character_type(height, mass, species, robots = FALSE)) %>%
+   pull(type)
 [1] "other" "other" "other" "large" "other" "other" "other" "other" "other"
[10] "other" "other" "other" "large" "other" "other" "large" "other" "other"
[19] "other" "other" "other" "other" "other" "other" "other" "other" "other"
[28] "other" "other" "other" "other" "other" "other" "other" "other" "large"
[37] "large" "other" "other" "other" "other" "other" "other" "other" "other"
[46] "other" "other" "other" "other" "other" "other" "other" "other" "other"
[55] "other" "large" "other" "other" "other" "other" "other" "other" "other"
[64] "other" "other" "other" "other" "other" "other" "other" "large" "large"
[73] "other" "other" "other" "other" "other" "large" "large" "other" "other"
[82] "large" "other" "other" "other" "other" "other"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("case_when", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("check_dbplyr")
> ### * check_dbplyr
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: check_dbplyr
> ### Title: dbplyr compatibility functions
> ### Aliases: check_dbplyr wrap_dbplyr_obj
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Don't show: 
> if (requireNamespace("dbplyr", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ wrap_dbplyr_obj("build_sql")
+ wrap_dbplyr_obj("base_agg")
+ ## Don't show: 
+ }) # examplesIf
> wrap_dbplyr_obj("build_sql")
build_sql <- function (obj_name) 
{
    if (utils::packageVersion("dplyr") > "0.5.0") {
        dplyr::check_dbplyr()
        dbplyr::build_sql(obj_name = obj_name)
    }
    else {
        dplyr::build_sql(obj_name = obj_name)
    }
}
> wrap_dbplyr_obj("base_agg")
base_agg <- function () 
{
    if (utils::packageVersion("dplyr") > "0.5.0") {
        dplyr::check_dbplyr()
        dbplyr::base_agg
    }
    else {
        dplyr::base_agg
    }
}
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("check_dbplyr", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("coalesce")
> ### * coalesce
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: coalesce
> ### Title: Find the first non-missing element
> ### Aliases: coalesce
> 
> ### ** Examples
> 
> # Use a single value to replace all missing values
> x <- sample(c(1:5, NA, NA, NA))
> coalesce(x, 0L)
[1] 1 4 0 2 0 3 0 5
> 
> # The equivalent to a missing value in a list is `NULL`
> coalesce(list(1, 2, NULL), list(NA))
[[1]]
[1] 1

[[2]]
[1] 2

[[3]]
[1] NA

> 
> # Or generate a complete vector from partially missing pieces
> y <- c(1, 2, NA, NA, 5)
> z <- c(NA, NA, 3, 4, 5)
> coalesce(y, z)
[1] 1 2 3 4 5
> 
> # Supply lists by splicing them into dots:
> vecs <- list(
+   c(1, 2, NA, NA, 5),
+   c(NA, NA, 3, 4, 5)
+ )
> coalesce(!!!vecs)
[1] 1 2 3 4 5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("coalesce", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("combine")
> ### * combine
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: combine
> ### Title: Combine vectors
> ### Aliases: combine
> ### Keywords: internal
> 
> ### ** Examples
> 
> f1 <- factor("a")
> f2 <- factor("b")
> 
> combine(f1, f2)
Warning: `combine()` was deprecated in dplyr 1.0.0.
ℹ Please use `vctrs::vec_c()` instead.
[1] a b
Levels: a b
> # ->
> vctrs::vec_c(f1, f1)
[1] a a
Levels: a
> 
> combine(list(f1, f2))
Warning: `combine()` was deprecated in dplyr 1.0.0.
ℹ Please use `vctrs::vec_c()` instead.
[1] a b
Levels: a b
> # ->
> vctrs::vec_c(!!!list(f1, f2))
[1] a b
Levels: a b
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("combine", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("compute")
> ### * compute
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: compute
> ### Title: Force computation of a database query
> ### Aliases: compute collect collapse
> 
> ### ** Examples
> 
> ## Don't show: 
> if (requireNamespace("dbplyr", quietly = TRUE) && requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ mtcars2 <- dbplyr::src_memdb() %>%
+   copy_to(mtcars, name = "mtcars2-cc", overwrite = TRUE)
+ 
+ remote <- mtcars2 %>%
+   filter(cyl == 8) %>%
+   select(mpg:drat)
+ 
+ # Compute query and save in remote table
+ compute(remote)
+ 
+ # Compute query bring back to this session
+ collect(remote)
+ 
+ # Creates a fresh query based on the generated SQL
+ collapse(remote)
+ ## Don't show: 
+ }) # examplesIf
> mtcars2 <- dbplyr::src_memdb() %>% copy_to(mtcars, name = "mtcars2-cc", 
+     overwrite = TRUE)
> remote <- mtcars2 %>% filter(cyl == 8) %>% select(mpg:drat)
> compute(remote)
# Source:   table<`dbplyr_uKOyTKKHP9`> [?? x 5]
# Database: sqlite 3.46.0 [:memory:]
     mpg   cyl  disp    hp  drat
   <dbl> <dbl> <dbl> <dbl> <dbl>
 1  18.7     8  360    175  3.15
 2  14.3     8  360    245  3.21
 3  16.4     8  276.   180  3.07
 4  17.3     8  276.   180  3.07
 5  15.2     8  276.   180  3.07
 6  10.4     8  472    205  2.93
 7  10.4     8  460    215  3   
 8  14.7     8  440    230  3.23
 9  15.5     8  318    150  2.76
10  15.2     8  304    150  3.15
# ℹ more rows
> collect(remote)
# A tibble: 14 × 5
     mpg   cyl  disp    hp  drat
   <dbl> <dbl> <dbl> <dbl> <dbl>
 1  18.7     8  360    175  3.15
 2  14.3     8  360    245  3.21
 3  16.4     8  276.   180  3.07
 4  17.3     8  276.   180  3.07
 5  15.2     8  276.   180  3.07
 6  10.4     8  472    205  2.93
 7  10.4     8  460    215  3   
 8  14.7     8  440    230  3.23
 9  15.5     8  318    150  2.76
10  15.2     8  304    150  3.15
11  13.3     8  350    245  3.73
12  19.2     8  400    175  3.08
13  15.8     8  351    264  4.22
14  15       8  301    335  3.54
> collapse(remote)
# Source:   SQL [?? x 5]
# Database: sqlite 3.46.0 [:memory:]
     mpg   cyl  disp    hp  drat
   <dbl> <dbl> <dbl> <dbl> <dbl>
 1  18.7     8  360    175  3.15
 2  14.3     8  360    245  3.21
 3  16.4     8  276.   180  3.07
 4  17.3     8  276.   180  3.07
 5  15.2     8  276.   180  3.07
 6  10.4     8  472    205  2.93
 7  10.4     8  460    215  3   
 8  14.7     8  440    230  3.23
 9  15.5     8  318    150  2.76
10  15.2     8  304    150  3.15
# ℹ more rows
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("compute", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'dbplyr_cache'

> nameEx("consecutive_id")
> ### * consecutive_id
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: consecutive_id
> ### Title: Generate a unique identifier for consecutive combinations
> ### Aliases: consecutive_id
> 
> ### ** Examples
> 
> consecutive_id(c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, NA, NA))
[1] 1 1 2 2 3 4 5 5
> consecutive_id(c(1, 1, 1, 2, 1, 1, 2, 2))
[1] 1 1 1 2 3 3 4 4
> 
> df <- data.frame(x = c(0, 0, 1, 0), y = c(2, 2, 2, 2))
> df %>% group_by(x, y) %>% summarise(n = n())
`summarise()` has grouped output by 'x'. You can override using the `.groups`
argument.
# A tibble: 2 × 3
# Groups:   x [2]
      x     y     n
  <dbl> <dbl> <int>
1     0     2     3
2     1     2     1
> df %>% group_by(id = consecutive_id(x, y), x, y) %>% summarise(n = n())
`summarise()` has grouped output by 'id', 'x'. You can override using the
`.groups` argument.
# A tibble: 3 × 4
# Groups:   id, x [3]
     id     x     y     n
  <int> <dbl> <dbl> <int>
1     1     0     2     2
2     2     1     2     1
3     3     0     2     1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("consecutive_id", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("context")
> ### * context
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: context
> ### Title: Information about the "current" group or variable
> ### Aliases: context n cur_group cur_group_id cur_group_rows cur_column
> 
> ### ** Examples
> 
> df <- tibble(
+   g = sample(rep(letters[1:3], 1:3)),
+   x = runif(6),
+   y = runif(6)
+ )
> gf <- df %>% group_by(g)
> 
> gf %>% summarise(n = n())
# A tibble: 3 × 2
  g         n
  <chr> <int>
1 a         1
2 b         2
3 c         3
> 
> gf %>% mutate(id = cur_group_id())
# A tibble: 6 × 4
# Groups:   g [3]
  g          x     y    id
  <chr>  <dbl> <dbl> <int>
1 a     0.945  0.687     1
2 c     0.661  0.384     3
3 b     0.629  0.770     2
4 c     0.0618 0.498     3
5 b     0.206  0.718     2
6 c     0.177  0.992     3
> gf %>% reframe(row = cur_group_rows())
# A tibble: 6 × 2
  g       row
  <chr> <int>
1 a         1
2 b         3
3 b         5
4 c         2
5 c         4
6 c         6
> gf %>% summarise(data = list(cur_group()))
# A tibble: 3 × 2
  g     data            
  <chr> <list>          
1 a     <tibble [1 × 1]>
2 b     <tibble [1 × 1]>
3 c     <tibble [1 × 1]>
> 
> gf %>% mutate(across(everything(), ~ paste(cur_column(), round(.x, 2))))
# A tibble: 6 × 3
# Groups:   g [3]
  g     x      y     
  <chr> <chr>  <chr> 
1 a     x 0.94 y 0.69
2 c     x 0.66 y 0.38
3 b     x 0.63 y 0.77
4 c     x 0.06 y 0.5 
5 b     x 0.21 y 0.72
6 c     x 0.18 y 0.99
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("context", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("copy_to")
> ### * copy_to
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: copy_to
> ### Title: Copy a local data frame to a remote src
> ### Aliases: copy_to
> 
> ### ** Examples
> 
> ## Not run: 
> ##D iris2 <- dbplyr::src_memdb() %>% copy_to(iris, overwrite = TRUE)
> ##D iris2
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("copy_to", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("count")
> ### * count
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: count
> ### Title: Count the observations in each group
> ### Aliases: count count.data.frame tally add_count add_tally
> 
> ### ** Examples
> 
> # count() is a convenient way to get a sense of the distribution of
> # values in a dataset
> starwars %>% count(species)
# A tibble: 38 × 2
   species       n
   <chr>     <int>
 1 Aleena        1
 2 Besalisk      1
 3 Cerean        1
 4 Chagrian      1
 5 Clawdite      1
 6 Droid         6
 7 Dug           1
 8 Ewok          1
 9 Geonosian     1
10 Gungan        3
# ℹ 28 more rows
> starwars %>% count(species, sort = TRUE)
# A tibble: 38 × 2
   species      n
   <chr>    <int>
 1 Human       35
 2 Droid        6
 3 <NA>         4
 4 Gungan       3
 5 Kaminoan     2
 6 Mirialan     2
 7 Twi'lek      2
 8 Wookiee      2
 9 Zabrak       2
10 Aleena       1
# ℹ 28 more rows
> starwars %>% count(sex, gender, sort = TRUE)
# A tibble: 6 × 3
  sex            gender        n
  <chr>          <chr>     <int>
1 male           masculine    60
2 female         feminine     16
3 none           masculine     5
4 <NA>           <NA>          4
5 hermaphroditic masculine     1
6 none           feminine      1
> starwars %>% count(birth_decade = round(birth_year, -1))
# A tibble: 15 × 2
   birth_decade     n
          <dbl> <int>
 1           10     1
 2           20     6
 3           30     4
 4           40     6
 5           50     8
 6           60     4
 7           70     4
 8           80     2
 9           90     3
10          100     1
11          110     1
12          200     1
13          600     1
14          900     1
15           NA    44
> 
> # use the `wt` argument to perform a weighted count. This is useful
> # when the data has already been aggregated once
> df <- tribble(
+   ~name,    ~gender,   ~runs,
+   "Max",    "male",       10,
+   "Sandra", "female",      1,
+   "Susan",  "female",      4
+ )
> # counts rows:
> df %>% count(gender)
# A tibble: 2 × 2
  gender     n
  <chr>  <int>
1 female     2
2 male       1
> # counts runs:
> df %>% count(gender, wt = runs)
# A tibble: 2 × 2
  gender     n
  <chr>  <dbl>
1 female     5
2 male      10
> 
> # When factors are involved, `.drop = FALSE` can be used to retain factor
> # levels that don't appear in the data
> df2 <- tibble(
+   id = 1:5,
+   type = factor(c("a", "c", "a", NA, "a"), levels = c("a", "b", "c"))
+ )
> df2 %>% count(type)
# A tibble: 3 × 2
  type      n
  <fct> <int>
1 a         3
2 c         1
3 <NA>      1
> df2 %>% count(type, .drop = FALSE)
# A tibble: 4 × 2
  type      n
  <fct> <int>
1 a         3
2 b         0
3 c         1
4 <NA>      1
> 
> # Or, using `group_by()`:
> df2 %>% group_by(type, .drop = FALSE) %>% count()
# A tibble: 4 × 2
# Groups:   type [4]
  type      n
  <fct> <int>
1 a         3
2 b         0
3 c         1
4 <NA>      1
> 
> # tally() is a lower-level function that assumes you've done the grouping
> starwars %>% tally()
# A tibble: 1 × 1
      n
  <int>
1    87
> starwars %>% group_by(species) %>% tally()
# A tibble: 38 × 2
   species       n
   <chr>     <int>
 1 Aleena        1
 2 Besalisk      1
 3 Cerean        1
 4 Chagrian      1
 5 Clawdite      1
 6 Droid         6
 7 Dug           1
 8 Ewok          1
 9 Geonosian     1
10 Gungan        3
# ℹ 28 more rows
> 
> # both count() and tally() have add_ variants that work like
> # mutate() instead of summarise
> df %>% add_count(gender, wt = runs)
# A tibble: 3 × 4
  name   gender  runs     n
  <chr>  <chr>  <dbl> <dbl>
1 Max    male      10    10
2 Sandra female     1     5
3 Susan  female     4     5
> df %>% add_tally(wt = runs)
# A tibble: 3 × 4
  name   gender  runs     n
  <chr>  <chr>  <dbl> <dbl>
1 Max    male      10    15
2 Sandra female     1    15
3 Susan  female     4    15
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("count", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cross_join")
> ### * cross_join
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cross_join
> ### Title: Cross join
> ### Aliases: cross_join
> 
> ### ** Examples
> 
> # Cross joins match each row in `x` to every row in `y`.
> # Data within the columns is not used in the matching process.
> cross_join(band_instruments, band_members)
# A tibble: 9 × 4
  name.x plays  name.y band   
  <chr>  <chr>  <chr>  <chr>  
1 John   guitar Mick   Stones 
2 John   guitar John   Beatles
3 John   guitar Paul   Beatles
4 Paul   bass   Mick   Stones 
5 Paul   bass   John   Beatles
6 Paul   bass   Paul   Beatles
7 Keith  guitar Mick   Stones 
8 Keith  guitar John   Beatles
9 Keith  guitar Paul   Beatles
> 
> # Control the suffix added to variables duplicated in
> # `x` and `y` with `suffix`.
> cross_join(band_instruments, band_members, suffix = c("", "_y"))
# A tibble: 9 × 4
  name  plays  name_y band   
  <chr> <chr>  <chr>  <chr>  
1 John  guitar Mick   Stones 
2 John  guitar John   Beatles
3 John  guitar Paul   Beatles
4 Paul  bass   Mick   Stones 
5 Paul  bass   John   Beatles
6 Paul  bass   Paul   Beatles
7 Keith guitar Mick   Stones 
8 Keith guitar John   Beatles
9 Keith guitar Paul   Beatles
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cross_join", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cumall")
> ### * cumall
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cumall
> ### Title: Cumulativate versions of any, all, and mean
> ### Aliases: cumall cumany cummean
> 
> ### ** Examples
> 
> # `cummean()` returns a numeric/integer vector of the same length
> # as the input vector.
> x <- c(1, 3, 5, 2, 2)
> cummean(x)
[1] 1.00 2.00 3.00 2.75 2.60
> cumsum(x) / seq_along(x)
[1] 1.00 2.00 3.00 2.75 2.60
> 
> # `cumall()` and `cumany()` return logicals
> cumall(x < 5)
[1]  TRUE  TRUE FALSE FALSE FALSE
> cumany(x == 3)
[1] FALSE  TRUE  TRUE  TRUE  TRUE
> 
> # `cumall()` vs. `cumany()`
> df <- data.frame(
+   date = as.Date("2020-01-01") + 0:6,
+   balance = c(100, 50, 25, -25, -50, 30, 120)
+ )
> # all rows after first overdraft
> df %>% filter(cumany(balance < 0))
        date balance
1 2020-01-04     -25
2 2020-01-05     -50
3 2020-01-06      30
4 2020-01-07     120
> # all rows until first overdraft
> df %>% filter(cumall(!(balance < 0)))
        date balance
1 2020-01-01     100
2 2020-01-02      50
3 2020-01-03      25
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cumall", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("desc")
> ### * desc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: desc
> ### Title: Descending order
> ### Aliases: desc
> 
> ### ** Examples
> 
> desc(1:10)
 [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10
> desc(factor(letters))
 [1]  -1  -2  -3  -4  -5  -6  -7  -8  -9 -10 -11 -12 -13 -14 -15 -16 -17 -18 -19
[20] -20 -21 -22 -23 -24 -25 -26
> 
> first_day <- seq(as.Date("1910/1/1"), as.Date("1920/1/1"), "years")
> desc(first_day)
 [1] 21915 21550 21185 20819 20454 20089 19724 19358 18993 18628 18263
> 
> starwars %>% arrange(desc(mass))
# A tibble: 87 × 14
   name     height  mass hair_color skin_color eye_color birth_year sex   gender
   <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Jabba D…    175  1358 <NA>       green-tan… orange         600   herm… mascu…
 2 Grievous    216   159 none       brown, wh… green, y…       NA   male  mascu…
 3 IG-88       200   140 none       metal      red             15   none  mascu…
 4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
 5 Tarfful     234   136 brown      brown      blue            NA   male  mascu…
 6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
 7 Bossk       190   113 none       green      red             53   male  mascu…
 8 Chewbac…    228   112 brown      unknown    blue           200   male  mascu…
 9 Jek Ton…    180   110 brown      fair       blue            NA   <NA>  <NA>  
10 Dexter …    198   102 none       brown      yellow          NA   male  mascu…
# ℹ 77 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("desc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("dim_desc")
> ### * dim_desc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: dim_desc
> ### Title: Describing dimensions
> ### Aliases: dim_desc
> ### Keywords: internal
> 
> ### ** Examples
> 
> dim_desc(mtcars)
[1] "[32 x 11]"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("dim_desc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("distinct")
> ### * distinct
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: distinct
> ### Title: Keep distinct/unique rows
> ### Aliases: distinct
> 
> ### ** Examples
> 
> df <- tibble(
+   x = sample(10, 100, rep = TRUE),
+   y = sample(10, 100, rep = TRUE)
+ )
> nrow(df)
[1] 100
> nrow(distinct(df))
[1] 65
> nrow(distinct(df, x, y))
[1] 65
> 
> distinct(df, x)
# A tibble: 10 × 1
       x
   <int>
 1     9
 2     4
 3     7
 4     1
 5     2
 6     3
 7     5
 8    10
 9     6
10     8
> distinct(df, y)
# A tibble: 10 × 1
       y
   <int>
 1     3
 2    10
 3     1
 4     6
 5     4
 6     9
 7     5
 8     7
 9     2
10     8
> 
> # You can choose to keep all other variables as well
> distinct(df, x, .keep_all = TRUE)
# A tibble: 10 × 2
       x     y
   <int> <int>
 1     9     3
 2     4    10
 3     7     3
 4     1     1
 5     2     6
 6     3     9
 7     5     1
 8    10     6
 9     6     3
10     8     2
> distinct(df, y, .keep_all = TRUE)
# A tibble: 10 × 2
       x     y
   <int> <int>
 1     9     3
 2     4    10
 3     1     1
 4     2     6
 5     2     4
 6     3     9
 7     1     5
 8    10     7
 9     9     2
10     9     8
> 
> # You can also use distinct on computed variables
> distinct(df, diff = abs(x - y))
# A tibble: 9 × 1
   diff
  <int>
1     6
2     4
3     0
4     1
5     2
6     3
7     7
8     5
9     8
> 
> # Use `pick()` to select columns with tidy-select
> distinct(starwars, pick(contains("color")))
# A tibble: 67 × 3
   hair_color    skin_color  eye_color
   <chr>         <chr>       <chr>    
 1 blond         fair        blue     
 2 <NA>          gold        yellow   
 3 <NA>          white, blue red      
 4 none          white       yellow   
 5 brown         light       brown    
 6 brown, grey   light       blue     
 7 brown         light       blue     
 8 <NA>          white, red  red      
 9 black         light       brown    
10 auburn, white fair        blue-gray
# ℹ 57 more rows
> 
> # Grouping -------------------------------------------------
> 
> df <- tibble(
+   g = c(1, 1, 2, 2, 2),
+   x = c(1, 1, 2, 1, 2),
+   y = c(3, 2, 1, 3, 1)
+ )
> df <- df %>% group_by(g)
> 
> # With grouped data frames, distinctness is computed within each group
> df %>% distinct(x)
# A tibble: 3 × 2
# Groups:   g [2]
      g     x
  <dbl> <dbl>
1     1     1
2     2     2
3     2     1
> 
> # When `...` are omitted, `distinct()` still computes distinctness using
> # all variables in the data frame
> df %>% distinct()
# A tibble: 4 × 3
# Groups:   g [2]
      g     x     y
  <dbl> <dbl> <dbl>
1     1     1     3
2     1     1     2
3     2     2     1
4     2     1     3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("distinct", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("distinct_all")
> ### * distinct_all
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: distinct_all
> ### Title: Select distinct rows by a selection of variables
> ### Aliases: distinct_all distinct_at distinct_if
> ### Keywords: internal
> 
> ### ** Examples
> 
> df <- tibble(x = rep(2:5, each = 2) / 2, y = rep(2:3, each = 4) / 2)
> 
> distinct_all(df)
# A tibble: 4 × 2
      x     y
  <dbl> <dbl>
1   1     1  
2   1.5   1  
3   2     1.5
4   2.5   1.5
> # ->
> distinct(df, pick(everything()))
# A tibble: 4 × 2
      x     y
  <dbl> <dbl>
1   1     1  
2   1.5   1  
3   2     1.5
4   2.5   1.5
> 
> distinct_at(df, vars(x,y))
# A tibble: 4 × 2
      x     y
  <dbl> <dbl>
1   1     1  
2   1.5   1  
3   2     1.5
4   2.5   1.5
> # ->
> distinct(df, pick(x, y))
# A tibble: 4 × 2
      x     y
  <dbl> <dbl>
1   1     1  
2   1.5   1  
3   2     1.5
4   2.5   1.5
> 
> distinct_if(df, is.numeric)
# A tibble: 4 × 2
      x     y
  <dbl> <dbl>
1   1     1  
2   1.5   1  
3   2     1.5
4   2.5   1.5
> # ->
> distinct(df, pick(where(is.numeric)))
# A tibble: 4 × 2
      x     y
  <dbl> <dbl>
1   1     1  
2   1.5   1  
3   2     1.5
4   2.5   1.5
> 
> # You can supply a function that will be applied before extracting the distinct values
> # The variables of the sorted tibble keep their original values.
> distinct_all(df, round)
# A tibble: 3 × 2
      x     y
  <dbl> <dbl>
1     1     1
2     2     1
3     2     2
> # ->
> distinct(df, across(everything(), round))
# A tibble: 3 × 2
      x     y
  <dbl> <dbl>
1     1     1
2     2     1
3     2     2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("distinct_all", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("do")
> ### * do
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: do
> ### Title: Do anything
> ### Aliases: do
> ### Keywords: internal
> 
> ### ** Examples
> 
> # do() with unnamed arguments becomes reframe() or summarise()
> # . becomes pick()
> by_cyl <- mtcars %>% group_by(cyl)
> by_cyl %>% do(head(., 2))
# A tibble: 6 × 11
# Groups:   cyl [3]
    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
2  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
3  21       6  160    110  3.9   2.62  16.5     0     1     4     4
4  21       6  160    110  3.9   2.88  17.0     0     1     4     4
5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
6  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
> # ->
> by_cyl %>% reframe(head(pick(everything()), 2))
# A tibble: 6 × 11
    cyl   mpg  disp    hp  drat    wt  qsec    vs    am  gear  carb
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1     4  22.8  108     93  3.85  2.32  18.6     1     1     4     1
2     4  24.4  147.    62  3.69  3.19  20       1     0     4     2
3     6  21    160    110  3.9   2.62  16.5     0     1     4     4
4     6  21    160    110  3.9   2.88  17.0     0     1     4     4
5     8  18.7  360    175  3.15  3.44  17.0     0     0     3     2
6     8  14.3  360    245  3.21  3.57  15.8     0     0     3     4
> by_cyl %>% slice_head(n = 2)
# A tibble: 6 × 11
# Groups:   cyl [3]
    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
2  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
3  21       6  160    110  3.9   2.62  16.5     0     1     4     4
4  21       6  160    110  3.9   2.88  17.0     0     1     4     4
5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
6  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
> 
> # Can refer to variables directly
> by_cyl %>% do(mean = mean(.$vs))
# A tibble: 3 × 2
# Rowwise: 
    cyl mean     
  <dbl> <list>   
1     4 <dbl [1]>
2     6 <dbl [1]>
3     8 <dbl [1]>
> # ->
> by_cyl %>% summarise(mean = mean(vs))
# A tibble: 3 × 2
    cyl  mean
  <dbl> <dbl>
1     4 0.909
2     6 0.571
3     8 0    
> 
> # do() with named arguments becomes nest_by() + mutate() & list()
> models <- by_cyl %>% do(mod = lm(mpg ~ disp, data = .))
> # ->
> models <- mtcars %>%
+   nest_by(cyl) %>%
+   mutate(mod = list(lm(mpg ~ disp, data = data)))
> models %>% summarise(rsq = summary(mod)$r.squared)
Warning: call dbDisconnect() when finished working with a connection
`summarise()` has grouped output by 'cyl'. You can override using the `.groups`
argument.
# A tibble: 3 × 2
# Groups:   cyl [3]
    cyl    rsq
  <dbl>  <dbl>
1     4 0.648 
2     6 0.0106
3     8 0.270 
> 
> # use broom to turn models into data
> models %>% do(data.frame(
+   var = names(coef(.$mod)),
+   coef(summary(.$mod)))
+ )
# A tibble: 6 × 5
# Rowwise: 
  var         Estimate Std..Error t.value   Pr...t..
  <chr>          <dbl>      <dbl>   <dbl>      <dbl>
1 (Intercept) 40.9        3.59     11.4   0.00000120
2 disp        -0.135      0.0332   -4.07  0.00278   
3 (Intercept) 19.1        2.91      6.55  0.00124   
4 disp         0.00361    0.0156    0.232 0.826     
5 (Intercept) 22.0        3.35      6.59  0.0000259 
6 disp        -0.0196     0.00932  -2.11  0.0568    
> ## Don't show: 
> if (requireNamespace("broom", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # ->
+ models %>% reframe(broom::tidy(mod))
+ ## Don't show: 
+ }) # examplesIf
> models %>% reframe(broom::tidy(mod))
# A tibble: 6 × 6
    cyl term        estimate std.error statistic    p.value
  <dbl> <chr>          <dbl>     <dbl>     <dbl>      <dbl>
1     4 (Intercept) 40.9       3.59       11.4   0.00000120
2     4 disp        -0.135     0.0332     -4.07  0.00278   
3     6 (Intercept) 19.1       2.91        6.55  0.00124   
4     6 disp         0.00361   0.0156      0.232 0.826     
5     8 (Intercept) 22.0       3.35        6.59  0.0000259 
6     8 disp        -0.0196    0.00932    -2.11  0.0568    
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("do", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("dplyr-locale")
> ### * dplyr-locale
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: dplyr-locale
> ### Title: Locale used by 'arrange()'
> ### Aliases: dplyr-locale
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Don't show: 
> if (dplyr:::has_minimum_stringi()) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ df <- tibble(x = c("a", "b", "C", "B", "c"))
+ df
+ 
+ # Default locale is C, which groups the English alphabet by case, placing
+ # uppercase letters before lowercase letters.
+ arrange(df, x)
+ 
+ # The American English locale groups the alphabet by letter.
+ # Explicitly override `.locale` with `"en"` for this ordering.
+ arrange(df, x, .locale = "en")
+ 
+ # This Danish letter is expected to sort after `z`
+ df <- tibble(x = c("o", "p", "\u00F8", "z"))
+ df
+ 
+ # The American English locale sorts it right after `o`
+ arrange(df, x, .locale = "en")
+ 
+ # Using `"da"` for Danish ordering gives the expected result
+ arrange(df, x, .locale = "da")
+ 
+ # If you need the legacy behavior of `arrange()`, which respected the
+ # system locale, then you can set the global option `dplyr.legacy_locale`,
+ # but expect this to be removed in the future. We recommend that you use
+ # the `.locale` argument instead.
+ rlang::with_options(dplyr.legacy_locale = TRUE, {
+   arrange(df, x)
+ })
+ ## Don't show: 
+ }) # examplesIf
> df <- tibble(x = c("a", "b", "C", "B", "c"))
> df
# A tibble: 5 × 1
  x    
  <chr>
1 a    
2 b    
3 C    
4 B    
5 c    
> arrange(df, x)
# A tibble: 5 × 1
  x    
  <chr>
1 B    
2 C    
3 a    
4 b    
5 c    
> arrange(df, x, .locale = "en")
# A tibble: 5 × 1
  x    
  <chr>
1 a    
2 b    
3 B    
4 c    
5 C    
> df <- tibble(x = c("o", "p", "ø", "z"))
> df
# A tibble: 4 × 1
  x    
  <chr>
1 o    
2 p    
3 ø    
4 z    
> arrange(df, x, .locale = "en")
# A tibble: 4 × 1
  x    
  <chr>
1 o    
2 ø    
3 p    
4 z    
> arrange(df, x, .locale = "da")
# A tibble: 4 × 1
  x    
  <chr>
1 o    
2 p    
3 z    
4 ø    
> rlang::with_options(dplyr.legacy_locale = TRUE, {
+     arrange(df, x)
+ })
# A tibble: 4 × 1
  x    
  <chr>
1 o    
2 p    
3 z    
4 ø    
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("dplyr-locale", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("explain")
> ### * explain
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: explain
> ### Title: Explain details of a tbl
> ### Aliases: explain show_query
> 
> ### ** Examples
> 
> ## Don't show: 
> if (requireNamespace("dbplyr", quietly = TRUE) && requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("explain", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("filter-joins")
> ### * filter-joins
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: filter-joins
> ### Title: Filtering joins
> ### Aliases: filter-joins semi_join semi_join.data.frame anti_join
> ###   anti_join.data.frame
> 
> ### ** Examples
> 
> # "Filtering" joins keep cases from the LHS
> band_members %>% semi_join(band_instruments)
Joining with `by = join_by(name)`
# A tibble: 2 × 2
  name  band   
  <chr> <chr>  
1 John  Beatles
2 Paul  Beatles
> band_members %>% anti_join(band_instruments)
Joining with `by = join_by(name)`
# A tibble: 1 × 2
  name  band  
  <chr> <chr> 
1 Mick  Stones
> 
> # To suppress the message about joining variables, supply `by`
> band_members %>% semi_join(band_instruments, by = join_by(name))
# A tibble: 2 × 2
  name  band   
  <chr> <chr>  
1 John  Beatles
2 Paul  Beatles
> # This is good practice in production code
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("filter-joins", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("filter")
> ### * filter
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: filter
> ### Title: Keep rows that match a condition
> ### Aliases: filter
> 
> ### ** Examples
> 
> # Filtering by one criterion
> filter(starwars, species == "Human")
# A tibble: 35 × 14
   name     height  mass hair_color skin_color eye_color birth_year sex   gender
   <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…
 2 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
 3 Leia Or…    150    49 brown      light      brown           19   fema… femin…
 4 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
 5 Beru Wh…    165    75 brown      light      blue            47   fema… femin…
 6 Biggs D…    183    84 black      light      brown           24   male  mascu…
 7 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…
 8 Anakin …    188    84 blond      fair       blue            41.9 male  mascu…
 9 Wilhuff…    180    NA auburn, g… fair       blue            64   male  mascu…
10 Han Solo    180    80 brown      fair       brown           29   male  mascu…
# ℹ 25 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> filter(starwars, mass > 1000)
# A tibble: 1 × 14
  name      height  mass hair_color skin_color eye_color birth_year sex   gender
  <chr>      <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
1 Jabba De…    175  1358 <NA>       green-tan… orange           600 herm… mascu…
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> # Filtering by multiple criteria within a single logical expression
> filter(starwars, hair_color == "none" & eye_color == "black")
# A tibble: 9 × 14
  name      height  mass hair_color skin_color eye_color birth_year sex   gender
  <chr>      <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
1 Nien Nunb    160    68 none       grey       black             NA male  mascu…
2 Gasgano      122    NA none       white, bl… black             NA male  mascu…
3 Kit Fisto    196    87 none       green      black             NA male  mascu…
4 Plo Koon     188    80 none       orange     black             22 male  mascu…
5 Lama Su      229    88 none       grey       black             NA male  mascu…
6 Taun We      213    NA none       grey       black             NA fema… femin…
7 Shaak Ti     178    57 none       red, blue… black             NA fema… femin…
8 Tion Med…    206    80 none       grey       black             NA male  mascu…
9 BB8           NA    NA none       none       black             NA none  mascu…
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> filter(starwars, hair_color == "none" | eye_color == "black")
# A tibble: 39 × 14
   name     height  mass hair_color skin_color eye_color birth_year sex   gender
   <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
 2 Greedo      173    74 <NA>       green      black           44   male  mascu…
 3 IG-88       200   140 none       metal      red             15   none  mascu…
 4 Bossk       190   113 none       green      red             53   male  mascu…
 5 Lobot       175    79 none       light      blue            37   male  mascu…
 6 Ackbar      180    83 none       brown mot… orange          41   male  mascu…
 7 Nien Nu…    160    68 none       grey       black           NA   male  mascu…
 8 Nute Gu…    191    90 none       mottled g… red             NA   male  mascu…
 9 Jar Jar…    196    66 none       orange     orange          52   male  mascu…
10 Roos Ta…    224    82 none       grey       orange          NA   male  mascu…
# ℹ 29 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> # When multiple expressions are used, they are combined using &
> filter(starwars, hair_color == "none", eye_color == "black")
# A tibble: 9 × 14
  name      height  mass hair_color skin_color eye_color birth_year sex   gender
  <chr>      <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
1 Nien Nunb    160    68 none       grey       black             NA male  mascu…
2 Gasgano      122    NA none       white, bl… black             NA male  mascu…
3 Kit Fisto    196    87 none       green      black             NA male  mascu…
4 Plo Koon     188    80 none       orange     black             22 male  mascu…
5 Lama Su      229    88 none       grey       black             NA male  mascu…
6 Taun We      213    NA none       grey       black             NA fema… femin…
7 Shaak Ti     178    57 none       red, blue… black             NA fema… femin…
8 Tion Med…    206    80 none       grey       black             NA male  mascu…
9 BB8           NA    NA none       none       black             NA none  mascu…
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> 
> # The filtering operation may yield different results on grouped
> # tibbles because the expressions are computed within groups.
> #
> # The following filters rows where `mass` is greater than the
> # global average:
> starwars %>% filter(mass > mean(mass, na.rm = TRUE))
# A tibble: 10 × 14
   name     height  mass hair_color skin_color eye_color birth_year sex   gender
   <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
 2 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
 3 Chewbac…    228   112 brown      unknown    blue           200   male  mascu…
 4 Jabba D…    175  1358 <NA>       green-tan… orange         600   herm… mascu…
 5 Jek Ton…    180   110 brown      fair       blue            NA   <NA>  <NA>  
 6 IG-88       200   140 none       metal      red             15   none  mascu…
 7 Bossk       190   113 none       green      red             53   male  mascu…
 8 Dexter …    198   102 none       brown      yellow          NA   male  mascu…
 9 Grievous    216   159 none       brown, wh… green, y…       NA   male  mascu…
10 Tarfful     234   136 brown      brown      blue            NA   male  mascu…
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> # Whereas this keeps rows with `mass` greater than the gender
> # average:
> starwars %>% group_by(gender) %>% filter(mass > mean(mass, na.rm = TRUE))
# A tibble: 15 × 14
# Groups:   gender [3]
   name    height   mass hair_color skin_color eye_color birth_year sex   gender
   <chr>    <int>  <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Darth …    202  136   none       white      yellow          41.9 male  mascu…
 2 Owen L…    178  120   brown, gr… light      blue            52   male  mascu…
 3 Beru W…    165   75   brown      light      blue            47   fema… femin…
 4 Chewba…    228  112   brown      unknown    blue           200   male  mascu…
 5 Jabba …    175 1358   <NA>       green-tan… orange         600   herm… mascu…
 6 Jek To…    180  110   brown      fair       blue            NA   <NA>  <NA>  
 7 IG-88      200  140   none       metal      red             15   none  mascu…
 8 Bossk      190  113   none       green      red             53   male  mascu…
 9 Ayla S…    178   55   none       blue       hazel           48   fema… femin…
10 Gregar…    185   85   black      dark       brown           NA   <NA>  <NA>  
11 Lumina…    170   56.2 black      yellow     blue            58   fema… femin…
12 Zam We…    168   55   blonde     fair, gre… yellow          NA   fema… femin…
13 Shaak …    178   57   none       red, blue… black           NA   fema… femin…
14 Grievo…    216  159   none       brown, wh… green, y…       NA   male  mascu…
15 Tarfful    234  136   brown      brown      blue            NA   male  mascu…
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> 
> # To refer to column names that are stored as strings, use the `.data` pronoun:
> vars <- c("mass", "height")
> cond <- c(80, 150)
> starwars %>%
+   filter(
+     .data[[vars[[1]]]] > cond[[1]],
+     .data[[vars[[2]]]] > cond[[2]]
+   )
# A tibble: 21 × 14
   name     height  mass hair_color skin_color eye_color birth_year sex   gender
   <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
 2 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
 3 Biggs D…    183    84 black      light      brown           24   male  mascu…
 4 Anakin …    188    84 blond      fair       blue            41.9 male  mascu…
 5 Chewbac…    228   112 brown      unknown    blue           200   male  mascu…
 6 Jabba D…    175  1358 <NA>       green-tan… orange         600   herm… mascu…
 7 Jek Ton…    180   110 brown      fair       blue            NA   <NA>  <NA>  
 8 IG-88       200   140 none       metal      red             15   none  mascu…
 9 Bossk       190   113 none       green      red             53   male  mascu…
10 Ackbar      180    83 none       brown mot… orange          41   male  mascu…
# ℹ 11 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> # Learn more in ?rlang::args_data_masking
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("filter", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("filter_all")
> ### * filter_all
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: filter_all
> ### Title: Filter within a selection of variables
> ### Aliases: filter_all filter_if filter_at
> ### Keywords: internal
> 
> ### ** Examples
> 
> # While filter() accepts expressions with specific variables, the
> # scoped filter verbs take an expression with the pronoun `.` and
> # replicate it over all variables. This expression should be quoted
> # with all_vars() or any_vars():
> all_vars(is.na(.))
<predicate intersection>
<quosure>
expr: ^is.na(.)
env:  global
> any_vars(is.na(.))
<predicate union>
<quosure>
expr: ^is.na(.)
env:  global
> 
> 
> # You can take the intersection of the replicated expressions:
> filter_all(mtcars, all_vars(. > 150))
 [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
<0 rows> (or 0-length row.names)
> # ->
> filter(mtcars, if_all(everything(), ~ .x > 150))
 [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb
<0 rows> (or 0-length row.names)
> 
> # Or the union:
> filter_all(mtcars, any_vars(. > 150))
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
> # ->
> filter(mtcars, if_any(everything(), ~ . > 150))
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
> 
> 
> # You can vary the selection of columns on which to apply the
> # predicate. filter_at() takes a vars() specification:
> filter_at(mtcars, vars(starts_with("d")), any_vars((. %% 2) == 0))
                     mpg cyl disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
Datsun 710          22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive      21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
Duster 360          14.3   8  360 245 3.21 3.570 15.84  0  0    3    4
Cadillac Fleetwood  10.4   8  472 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8  440 230 3.23 5.345 17.42  0  0    3    4
Dodge Challenger    15.5   8  318 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8  304 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8  350 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8  400 175 3.08 3.845 17.05  0  0    3    2
> # ->
> filter(mtcars, if_any(starts_with("d"), ~ (.x %% 2) == 0))
                     mpg cyl disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
Datsun 710          22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive      21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
Duster 360          14.3   8  360 245 3.21 3.570 15.84  0  0    3    4
Cadillac Fleetwood  10.4   8  472 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8  440 230 3.23 5.345 17.42  0  0    3    4
Dodge Challenger    15.5   8  318 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8  304 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8  350 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8  400 175 3.08 3.845 17.05  0  0    3    2
> 
> # And filter_if() selects variables with a predicate function:
> filter_if(mtcars, ~ all(floor(.) == .), all_vars(. != 0))
                mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> # ->
> is_int <- function(x) all(floor(x) == x)
> filter(mtcars, if_all(where(is_int), ~ .x != 0))
                mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("filter_all", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("funs")
> ### * funs
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: funs
> ### Title: Create a list of function calls
> ### Aliases: funs
> ### Keywords: internal
> 
> ### ** Examples
> 
> funs("mean", mean(., na.rm = TRUE))
Warning: `funs()` was deprecated in dplyr 0.8.0.
ℹ Please use a list of either functions or lambdas:

# Simple named list: list(mean = mean, median = median)

# Auto named with `tibble::lst()`: tibble::lst(mean, median)

# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))
<fun_calls>
$ mean: mean(.)
$ mean: mean(., na.rm = TRUE)
> # ->
> list(mean = mean, mean = ~ mean(.x, na.rm = TRUE))
$mean
function (x, ...) 
UseMethod("mean")
<bytecode: 0x000001e36ff17760>
<environment: namespace:base>

$mean
~mean(.x, na.rm = TRUE)

> 
> funs(m1 = mean, m2 = "mean", m3 = mean(., na.rm = TRUE))
Warning: `funs()` was deprecated in dplyr 0.8.0.
ℹ Please use a list of either functions or lambdas:

# Simple named list: list(mean = mean, median = median)

# Auto named with `tibble::lst()`: tibble::lst(mean, median)

# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))
<fun_calls>
$ m1: mean(.)
$ m2: mean(.)
$ m3: mean(., na.rm = TRUE)
> # ->
> list(m1 = mean, m2 = "mean", m3 = ~ mean(.x, na.rm = TRUE))
$m1
function (x, ...) 
UseMethod("mean")
<bytecode: 0x000001e36ff17760>
<environment: namespace:base>

$m2
[1] "mean"

$m3
~mean(.x, na.rm = TRUE)

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("funs", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("glimpse")
> ### * glimpse
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: glimpse
> ### Title: Get a glimpse of your data
> ### Aliases: glimpse
> 
> ### ** Examples
> 
> glimpse(mtcars)
Rows: 32
Columns: 11
$ mpg  <dbl> 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,…
$ cyl  <dbl> 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,…
$ disp <dbl> 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16…
$ hp   <dbl> 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180…
$ drat <dbl> 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,…
$ wt   <dbl> 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.…
$ qsec <dbl> 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18…
$ vs   <dbl> 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,…
$ am   <dbl> 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,…
$ gear <dbl> 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,…
$ carb <dbl> 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,…
> 
> # Note that original x is (invisibly) returned, allowing `glimpse()` to be
> # used within a pipeline.
> mtcars %>%
+   glimpse() %>%
+   select(1:3)
Rows: 32
Columns: 11
$ mpg  <dbl> 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,…
$ cyl  <dbl> 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,…
$ disp <dbl> 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16…
$ hp   <dbl> 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180…
$ drat <dbl> 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,…
$ wt   <dbl> 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.…
$ qsec <dbl> 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18…
$ vs   <dbl> 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,…
$ am   <dbl> 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,…
$ gear <dbl> 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,…
$ carb <dbl> 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,…
                     mpg cyl  disp
Mazda RX4           21.0   6 160.0
Mazda RX4 Wag       21.0   6 160.0
Datsun 710          22.8   4 108.0
Hornet 4 Drive      21.4   6 258.0
Hornet Sportabout   18.7   8 360.0
Valiant             18.1   6 225.0
Duster 360          14.3   8 360.0
Merc 240D           24.4   4 146.7
Merc 230            22.8   4 140.8
Merc 280            19.2   6 167.6
Merc 280C           17.8   6 167.6
Merc 450SE          16.4   8 275.8
Merc 450SL          17.3   8 275.8
Merc 450SLC         15.2   8 275.8
Cadillac Fleetwood  10.4   8 472.0
Lincoln Continental 10.4   8 460.0
Chrysler Imperial   14.7   8 440.0
Fiat 128            32.4   4  78.7
Honda Civic         30.4   4  75.7
Toyota Corolla      33.9   4  71.1
Toyota Corona       21.5   4 120.1
Dodge Challenger    15.5   8 318.0
AMC Javelin         15.2   8 304.0
Camaro Z28          13.3   8 350.0
Pontiac Firebird    19.2   8 400.0
Fiat X1-9           27.3   4  79.0
Porsche 914-2       26.0   4 120.3
Lotus Europa        30.4   4  95.1
Ford Pantera L      15.8   8 351.0
Ferrari Dino        19.7   6 145.0
Maserati Bora       15.0   8 301.0
Volvo 142E          21.4   4 121.0
> 
> glimpse(starwars)
Rows: 87
Columns: 14
$ name       <chr> "Luke Skywalker", "C-3PO", "R2-D2", "Darth Vader", "Leia Or…
$ height     <int> 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188, 180, 2…
$ mass       <dbl> 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 84.0, 77.…
$ hair_color <chr> "blond", NA, NA, "none", "brown", "brown, grey", "brown", N…
$ skin_color <chr> "fair", "gold", "white, blue", "white", "light", "light", "…
$ eye_color  <chr> "blue", "yellow", "red", "yellow", "brown", "blue", "blue",…
$ birth_year <dbl> 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0, 57.0, …
$ sex        <chr> "male", "none", "none", "male", "female", "male", "female",…
$ gender     <chr> "masculine", "masculine", "masculine", "masculine", "femini…
$ homeworld  <chr> "Tatooine", "Tatooine", "Naboo", "Tatooine", "Alderaan", "T…
$ species    <chr> "Human", "Droid", "Droid", "Human", "Human", "Human", "Huma…
$ films      <list> <"A New Hope", "The Empire Strikes Back", "Return of the J…
$ vehicles   <list> <"Snowspeeder", "Imperial Speeder Bike">, <>, <>, <>, "Imp…
$ starships  <list> <"X-wing", "Imperial shuttle">, <>, <>, "TIE Advanced x1",…
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("glimpse", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("group_by")
> ### * group_by
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: group_by
> ### Title: Group by one or more variables
> ### Aliases: group_by ungroup
> 
> ### ** Examples
> 
> by_cyl <- mtcars %>% group_by(cyl)
> 
> # grouping doesn't change how the data looks (apart from listing
> # how it's grouped):
> by_cyl
# A tibble: 32 × 11
# Groups:   cyl [3]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> 
> # It changes how it acts with the other dplyr verbs:
> by_cyl %>% summarise(
+   disp = mean(disp),
+   hp = mean(hp)
+ )
# A tibble: 3 × 3
    cyl  disp    hp
  <dbl> <dbl> <dbl>
1     4  105.  82.6
2     6  183. 122. 
3     8  353. 209. 
> by_cyl %>% filter(disp == max(disp))
# A tibble: 3 × 11
# Groups:   cyl [3]
    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
2  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
3  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4
> 
> # Each call to summarise() removes a layer of grouping
> by_vs_am <- mtcars %>% group_by(vs, am)
> by_vs <- by_vs_am %>% summarise(n = n())
`summarise()` has grouped output by 'vs'. You can override using the `.groups`
argument.
> by_vs
# A tibble: 4 × 3
# Groups:   vs [2]
     vs    am     n
  <dbl> <dbl> <int>
1     0     0    12
2     0     1     6
3     1     0     7
4     1     1     7
> by_vs %>% summarise(n = sum(n))
# A tibble: 2 × 2
     vs     n
  <dbl> <int>
1     0    18
2     1    14
> 
> # To removing grouping, use ungroup
> by_vs %>%
+   ungroup() %>%
+   summarise(n = sum(n))
# A tibble: 1 × 1
      n
  <int>
1    32
> 
> # By default, group_by() overrides existing grouping
> by_cyl %>%
+   group_by(vs, am) %>%
+   group_vars()
[1] "vs" "am"
> 
> # Use add = TRUE to instead append
> by_cyl %>%
+   group_by(vs, am, .add = TRUE) %>%
+   group_vars()
[1] "cyl" "vs"  "am" 
> 
> # You can group by expressions: this is a short-hand
> # for a mutate() followed by a group_by()
> mtcars %>%
+   group_by(vsam = vs + am)
# A tibble: 32 × 12
# Groups:   vsam [3]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb  vsam
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4     1
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4     1
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1     2
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2     0
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4     0
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2     1
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2     1
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4     1
# ℹ 22 more rows
> 
> # The implicit mutate() step is always performed on the
> # ungrouped data. Here we get 3 groups:
> mtcars %>%
+   group_by(vs) %>%
+   group_by(hp_cut = cut(hp, 3))
# A tibble: 32 × 12
# Groups:   hp_cut [3]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb hp_cut    
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <fct>     
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4 (51.7,146]
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4 (51.7,146]
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1 (51.7,146]
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1 (51.7,146]
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2 (146,241] 
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1 (51.7,146]
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4 (241,335] 
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2 (51.7,146]
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2 (51.7,146]
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 (51.7,146]
# ℹ 22 more rows
> 
> # If you want it to be performed by groups,
> # you have to use an explicit mutate() call.
> # Here we get 3 groups per value of vs
> mtcars %>%
+   group_by(vs) %>%
+   mutate(hp_cut = cut(hp, 3)) %>%
+   group_by(hp_cut)
# A tibble: 32 × 12
# Groups:   hp_cut [6]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb hp_cut     
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <fct>      
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4 (90.8,172] 
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4 (90.8,172] 
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1 (75.7,99.3]
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1 (99.3,123] 
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2 (172,254]  
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1 (99.3,123] 
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4 (172,254]  
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2 (51.9,75.7]
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2 (75.7,99.3]
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 (99.3,123] 
# ℹ 22 more rows
> 
> # when factors are involved and .drop = FALSE, groups can be empty
> tbl <- tibble(
+   x = 1:10,
+   y = factor(rep(c("a", "c"), each  = 5), levels = c("a", "b", "c"))
+ )
> tbl %>%
+   group_by(y, .drop = FALSE) %>%
+   group_rows()
<list_of<integer>[3]>
[[1]]
[1] 1 2 3 4 5

[[2]]
integer(0)

[[3]]
[1]  6  7  8  9 10

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("group_by", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("group_by_all")
> ### * group_by_all
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: group_by_all
> ### Title: Group by a selection of variables
> ### Aliases: group_by_all group_by_at group_by_if
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Group a data frame by all variables:
> group_by_all(mtcars)
# A tibble: 32 × 11
# Groups:   mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb [32]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> # ->
> mtcars %>% group_by(pick(everything()))
# A tibble: 32 × 11
# Groups:   mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb [32]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> 
> # Group by variables selected with a predicate:
> group_by_if(iris, is.factor)
# A tibble: 150 × 5
# Groups:   Species [3]
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> # ->
> iris %>% group_by(pick(where(is.factor)))
# A tibble: 150 × 5
# Groups:   Species [3]
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> 
> # Group by variables selected by name:
> group_by_at(mtcars, vars(vs, am))
# A tibble: 32 × 11
# Groups:   vs, am [4]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> # ->
> mtcars %>% group_by(pick(vs, am))
# A tibble: 32 × 11
# Groups:   vs, am [4]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> 
> # Like group_by(), the scoped variants have optional mutate
> # semantics. This provide a shortcut for group_by() + mutate():
> d <- tibble(x=c(1,1,2,2), y=c(1,2,1,2))
> group_by_all(d, as.factor)
# A tibble: 4 × 2
# Groups:   x, y [4]
  x     y    
  <fct> <fct>
1 1     1    
2 1     2    
3 2     1    
4 2     2    
> # ->
> d %>% group_by(across(everything(), as.factor))
# A tibble: 4 × 2
# Groups:   x, y [4]
  x     y    
  <fct> <fct>
1 1     1    
2 1     2    
3 2     1    
4 2     2    
> 
> group_by_if(iris, is.factor, as.character)
# A tibble: 150 × 5
# Groups:   Species [3]
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <chr>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> # ->
> iris %>% group_by(across(where(is.factor), as.character))
# A tibble: 150 × 5
# Groups:   Species [3]
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <chr>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("group_by_all", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("group_by_drop_default")
> ### * group_by_drop_default
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: group_by_drop_default
> ### Title: Default value for .drop argument of group_by
> ### Aliases: group_by_drop_default
> ### Keywords: internal
> 
> ### ** Examples
> 
> group_by_drop_default(iris)
[1] TRUE
> 
> iris %>%
+   group_by(Species) %>%
+   group_by_drop_default()
[1] TRUE
> 
> iris %>%
+   group_by(Species, .drop = FALSE) %>%
+   group_by_drop_default()
[1] FALSE
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("group_by_drop_default", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("group_cols")
> ### * group_cols
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: group_cols
> ### Title: Select grouping variables
> ### Aliases: group_cols
> 
> ### ** Examples
> 
> gdf <- iris %>% group_by(Species)
> gdf %>% select(group_cols())
# A tibble: 150 × 1
# Groups:   Species [3]
   Species
   <fct>  
 1 setosa 
 2 setosa 
 3 setosa 
 4 setosa 
 5 setosa 
 6 setosa 
 7 setosa 
 8 setosa 
 9 setosa 
10 setosa 
# ℹ 140 more rows
> 
> # Remove the grouping variables from mutate selections:
> gdf %>% mutate_at(vars(-group_cols()), `/`, 100)
# A tibble: 150 × 5
# Groups:   Species [3]
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1        0.051       0.035        0.014       0.002 setosa 
 2        0.049       0.03         0.014       0.002 setosa 
 3        0.047       0.032        0.013       0.002 setosa 
 4        0.046       0.031        0.015       0.002 setosa 
 5        0.05        0.036        0.014       0.002 setosa 
 6        0.054       0.039        0.017       0.004 setosa 
 7        0.046       0.034        0.014       0.003 setosa 
 8        0.05        0.034        0.015       0.002 setosa 
 9        0.044       0.029        0.014       0.002 setosa 
10        0.049       0.031        0.015       0.001 setosa 
# ℹ 140 more rows
> # -> No longer necessary with across()
> gdf %>% mutate(across(everything(), ~ . / 100))
# A tibble: 150 × 5
# Groups:   Species [3]
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1        0.051       0.035        0.014       0.002 setosa 
 2        0.049       0.03         0.014       0.002 setosa 
 3        0.047       0.032        0.013       0.002 setosa 
 4        0.046       0.031        0.015       0.002 setosa 
 5        0.05        0.036        0.014       0.002 setosa 
 6        0.054       0.039        0.017       0.004 setosa 
 7        0.046       0.034        0.014       0.003 setosa 
 8        0.05        0.034        0.015       0.002 setosa 
 9        0.044       0.029        0.014       0.002 setosa 
10        0.049       0.031        0.015       0.001 setosa 
# ℹ 140 more rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("group_cols", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("group_data")
> ### * group_data
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: group_data
> ### Title: Grouping metadata
> ### Aliases: group_data group_keys group_rows group_indices group_vars
> ###   groups group_size n_groups
> ### Keywords: internal
> 
> ### ** Examples
> 
> df <- tibble(x = c(1,1,2,2))
> group_vars(df)
character(0)
> group_rows(df)
<list_of<integer>[1]>
[[1]]
[1] 1 2 3 4

> group_data(df)
# A tibble: 1 × 1
        .rows
  <list<int>>
1         [4]
> group_indices(df)
[1] 1 1 1 1
> 
> gf <- group_by(df, x)
> group_vars(gf)
[1] "x"
> group_rows(gf)
<list_of<integer>[2]>
[[1]]
[1] 1 2

[[2]]
[1] 3 4

> group_data(gf)
# A tibble: 2 × 2
      x       .rows
  <dbl> <list<int>>
1     1         [2]
2     2         [2]
> group_indices(gf)
[1] 1 1 2 2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("group_data", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("group_map")
> ### * group_map
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: group_map
> ### Title: Apply a function to each group
> ### Aliases: group_map group_modify group_walk
> 
> ### ** Examples
> 
> 
> # return a list
> mtcars %>%
+   group_by(cyl) %>%
+   group_map(~ head(.x, 2L))
[[1]]
# A tibble: 2 × 10
    mpg  disp    hp  drat    wt  qsec    vs    am  gear  carb
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1  22.8  108     93  3.85  2.32  18.6     1     1     4     1
2  24.4  147.    62  3.69  3.19  20       1     0     4     2

[[2]]
# A tibble: 2 × 10
    mpg  disp    hp  drat    wt  qsec    vs    am  gear  carb
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1    21   160   110   3.9  2.62  16.5     0     1     4     4
2    21   160   110   3.9  2.88  17.0     0     1     4     4

[[3]]
# A tibble: 2 × 10
    mpg  disp    hp  drat    wt  qsec    vs    am  gear  carb
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1  18.7   360   175  3.15  3.44  17.0     0     0     3     2
2  14.3   360   245  3.21  3.57  15.8     0     0     3     4

> 
> # return a tibble grouped by `cyl` with 2 rows per group
> # the grouping data is recalculated
> mtcars %>%
+   group_by(cyl) %>%
+   group_modify(~ head(.x, 2L))
# A tibble: 6 × 11
# Groups:   cyl [3]
    cyl   mpg  disp    hp  drat    wt  qsec    vs    am  gear  carb
  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
1     4  22.8  108     93  3.85  2.32  18.6     1     1     4     1
2     4  24.4  147.    62  3.69  3.19  20       1     0     4     2
3     6  21    160    110  3.9   2.62  16.5     0     1     4     4
4     6  21    160    110  3.9   2.88  17.0     0     1     4     4
5     8  18.7  360    175  3.15  3.44  17.0     0     0     3     2
6     8  14.3  360    245  3.21  3.57  15.8     0     0     3     4
> ## Don't show: 
> if (requireNamespace("broom", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ 
+ # a list of tibbles
+ iris %>%
+   group_by(Species) %>%
+   group_map(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x)))
+ 
+ # a restructured grouped tibble
+ iris %>%
+   group_by(Species) %>%
+   group_modify(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x)))
+ ## Don't show: 
+ }) # examplesIf
> iris %>% group_by(Species) %>% group_map(~broom::tidy(lm(Petal.Length ~ 
+     Sepal.Length, data = .x)))
[[1]]
# A tibble: 2 × 5
  term         estimate std.error statistic p.value
  <chr>           <dbl>     <dbl>     <dbl>   <dbl>
1 (Intercept)     0.803    0.344       2.34  0.0238
2 Sepal.Length    0.132    0.0685      1.92  0.0607

[[2]]
# A tibble: 2 × 5
  term         estimate std.error statistic  p.value
  <chr>           <dbl>     <dbl>     <dbl>    <dbl>
1 (Intercept)     0.185    0.514      0.360 7.20e- 1
2 Sepal.Length    0.686    0.0863     7.95  2.59e-10

[[3]]
# A tibble: 2 × 5
  term         estimate std.error statistic  p.value
  <chr>           <dbl>     <dbl>     <dbl>    <dbl>
1 (Intercept)     0.610    0.417       1.46 1.50e- 1
2 Sepal.Length    0.750    0.0630     11.9  6.30e-16

> iris %>% group_by(Species) %>% group_modify(~broom::tidy(lm(Petal.Length ~ 
+     Sepal.Length, data = .x)))
# A tibble: 6 × 6
# Groups:   Species [3]
  Species    term         estimate std.error statistic  p.value
  <fct>      <chr>           <dbl>     <dbl>     <dbl>    <dbl>
1 setosa     (Intercept)     0.803    0.344      2.34  2.38e- 2
2 setosa     Sepal.Length    0.132    0.0685     1.92  6.07e- 2
3 versicolor (Intercept)     0.185    0.514      0.360 7.20e- 1
4 versicolor Sepal.Length    0.686    0.0863     7.95  2.59e-10
5 virginica  (Intercept)     0.610    0.417      1.46  1.50e- 1
6 virginica  Sepal.Length    0.750    0.0630    11.9   6.30e-16
> ## End(Don't show)
> 
> # a list of vectors
> iris %>%
+   group_by(Species) %>%
+   group_map(~ quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)))
[[1]]
  25%   50%   75% 
1.400 1.500 1.575 

[[2]]
 25%  50%  75% 
4.00 4.35 4.60 

[[3]]
  25%   50%   75% 
5.100 5.550 5.875 

> 
> # to use group_modify() the lambda must return a data frame
> iris %>%
+   group_by(Species) %>%
+   group_modify(~ {
+      quantile(.x$Petal.Length, probs = c(0.25, 0.5, 0.75)) %>%
+      tibble::enframe(name = "prob", value = "quantile")
+   })
# A tibble: 9 × 3
# Groups:   Species [3]
  Species    prob  quantile
  <fct>      <chr>    <dbl>
1 setosa     25%       1.4 
2 setosa     50%       1.5 
3 setosa     75%       1.58
4 versicolor 25%       4   
5 versicolor 50%       4.35
6 versicolor 75%       4.6 
7 virginica  25%       5.1 
8 virginica  50%       5.55
9 virginica  75%       5.88
> 
> iris %>%
+   group_by(Species) %>%
+   group_modify(~ {
+     .x %>%
+       purrr::map_dfc(fivenum) %>%
+       mutate(nms = c("min", "Q1", "median", "Q3", "max"))
+   })
# A tibble: 15 × 6
# Groups:   Species [3]
   Species    Sepal.Length Sepal.Width Petal.Length Petal.Width nms   
   <fct>             <dbl>       <dbl>        <dbl>       <dbl> <chr> 
 1 setosa              4.3         2.3         1            0.1 min   
 2 setosa              4.8         3.2         1.4          0.2 Q1    
 3 setosa              5           3.4         1.5          0.2 median
 4 setosa              5.2         3.7         1.6          0.3 Q3    
 5 setosa              5.8         4.4         1.9          0.6 max   
 6 versicolor          4.9         2           3            1   min   
 7 versicolor          5.6         2.5         4            1.2 Q1    
 8 versicolor          5.9         2.8         4.35         1.3 median
 9 versicolor          6.3         3           4.6          1.5 Q3    
10 versicolor          7           3.4         5.1          1.8 max   
11 virginica           4.9         2.2         4.5          1.4 min   
12 virginica           6.2         2.8         5.1          1.8 Q1    
13 virginica           6.5         3           5.55         2   median
14 virginica           6.9         3.2         5.9          2.3 Q3    
15 virginica           7.9         3.8         6.9          2.5 max   
> 
> # group_walk() is for side effects
> dir.create(temp <- tempfile())
> iris %>%
+   group_by(Species) %>%
+   group_walk(~ write.csv(.x, file = file.path(temp, paste0(.y$Species, ".csv"))))
> list.files(temp, pattern = "csv$")
[1] "setosa.csv"     "versicolor.csv" "virginica.csv" 
> unlink(temp, recursive = TRUE)
> 
> # group_modify() and ungrouped data frames
> mtcars %>%
+   group_modify(~ head(.x, 2L))
              mpg cyl disp  hp drat    wt  qsec vs am gear carb
Mazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4
Mazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("group_map", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("group_nest")
> ### * group_nest
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: group_nest
> ### Title: Nest a tibble using a grouping specification
> ### Aliases: group_nest
> ### Keywords: internal
> 
> ### ** Examples
> 
> 
> #----- use case 1: a grouped data frame
> iris %>%
+   group_by(Species) %>%
+   group_nest()
# A tibble: 3 × 2
  Species                  data
  <fct>      <list<tibble[,4]>>
1 setosa               [50 × 4]
2 versicolor           [50 × 4]
3 virginica            [50 × 4]
> 
> # this can be useful if the grouped data has been altered before nesting
> iris %>%
+   group_by(Species) %>%
+   filter(Sepal.Length > mean(Sepal.Length)) %>%
+   group_nest()
# A tibble: 3 × 2
  Species                  data
  <fct>      <list<tibble[,4]>>
1 setosa               [22 × 4]
2 versicolor           [24 × 4]
3 virginica            [22 × 4]
> 
> #----- use case 2: using group_nest() on a ungrouped data frame with
> #                  a grouping specification that uses the data mask
> starwars %>%
+   group_nest(species, homeworld)
# A tibble: 57 × 3
   species  homeworld                  data
   <chr>    <chr>       <list<tibble[,12]>>
 1 Aleena   Aleen Minor            [1 × 12]
 2 Besalisk Ojom                   [1 × 12]
 3 Cerean   Cerea                  [1 × 12]
 4 Chagrian Champala               [1 × 12]
 5 Clawdite Zolan                  [1 × 12]
 6 Droid    Naboo                  [1 × 12]
 7 Droid    Tatooine               [2 × 12]
 8 Droid    <NA>                   [3 × 12]
 9 Dug      Malastare              [1 × 12]
10 Ewok     Endor                  [1 × 12]
# ℹ 47 more rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("group_nest", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("group_split")
> ### * group_split
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: group_split
> ### Title: Split data frame by groups
> ### Aliases: group_split
> ### Keywords: internal
> 
> ### ** Examples
> 
> ir <- iris %>% group_by(Species)
> 
> group_split(ir)
<list_of<
  tbl_df<
    Sepal.Length: double
    Sepal.Width : double
    Petal.Length: double
    Petal.Width : double
    Species     : factor<fb977>
  >
>[3]>
[[1]]
# A tibble: 50 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 40 more rows

[[2]]
# A tibble: 50 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species   
          <dbl>       <dbl>        <dbl>       <dbl> <fct>     
 1          7           3.2          4.7         1.4 versicolor
 2          6.4         3.2          4.5         1.5 versicolor
 3          6.9         3.1          4.9         1.5 versicolor
 4          5.5         2.3          4           1.3 versicolor
 5          6.5         2.8          4.6         1.5 versicolor
 6          5.7         2.8          4.5         1.3 versicolor
 7          6.3         3.3          4.7         1.6 versicolor
 8          4.9         2.4          3.3         1   versicolor
 9          6.6         2.9          4.6         1.3 versicolor
10          5.2         2.7          3.9         1.4 versicolor
# ℹ 40 more rows

[[3]]
# A tibble: 50 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species  
          <dbl>       <dbl>        <dbl>       <dbl> <fct>    
 1          6.3         3.3          6           2.5 virginica
 2          5.8         2.7          5.1         1.9 virginica
 3          7.1         3            5.9         2.1 virginica
 4          6.3         2.9          5.6         1.8 virginica
 5          6.5         3            5.8         2.2 virginica
 6          7.6         3            6.6         2.1 virginica
 7          4.9         2.5          4.5         1.7 virginica
 8          7.3         2.9          6.3         1.8 virginica
 9          6.7         2.5          5.8         1.8 virginica
10          7.2         3.6          6.1         2.5 virginica
# ℹ 40 more rows

> group_keys(ir)
# A tibble: 3 × 1
  Species   
  <fct>     
1 setosa    
2 versicolor
3 virginica 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("group_split", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("group_trim")
> ### * group_trim
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: group_trim
> ### Title: Trim grouping structure
> ### Aliases: group_trim
> 
> ### ** Examples
> 
> iris %>%
+   group_by(Species) %>%
+   filter(Species == "setosa", .preserve = TRUE) %>%
+   group_trim()
# A tibble: 50 × 5
# Groups:   Species [1]
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 40 more rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("group_trim", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ident")
> ### * ident
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ident
> ### Title: Flag a character vector as SQL identifiers
> ### Aliases: ident
> 
> ### ** Examples
> 
> # Identifiers are escaped with "
> ## Don't show: 
> if (requireNamespace("dbplyr", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ ident("x")
+ ## Don't show: 
+ }) # examplesIf
> ident("x")
<IDENT> x
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ident", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("if_else")
> ### * if_else
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: if_else
> ### Title: Vectorised if-else
> ### Aliases: if_else
> 
> ### ** Examples
> 
> x <- c(-5:5, NA)
> if_else(x < 0, NA, x)
 [1] NA NA NA NA NA  0  1  2  3  4  5 NA
> 
> # Explicitly handle `NA` values in the `condition` with `missing`
> if_else(x < 0, "negative", "positive", missing = "missing")
 [1] "negative" "negative" "negative" "negative" "negative" "positive"
 [7] "positive" "positive" "positive" "positive" "positive" "missing" 
> 
> # Unlike `ifelse()`, `if_else()` preserves types
> x <- factor(sample(letters[1:5], 10, replace = TRUE))
> ifelse(x %in% c("a", "b", "c"), x, NA)
 [1]  1 NA  1  2 NA  3  2  3  3  1
> if_else(x %in% c("a", "b", "c"), x, NA)
 [1] a    <NA> a    b    <NA> c    b    c    c    a   
Levels: a b c d e
> 
> # `if_else()` is often useful for creating new columns inside of `mutate()`
> starwars %>%
+   mutate(category = if_else(height < 100, "short", "tall"), .keep = "used")
# A tibble: 87 × 2
   height category
    <int> <chr>   
 1    172 tall    
 2    167 tall    
 3     96 short   
 4    202 tall    
 5    150 tall    
 6    178 tall    
 7    165 tall    
 8     97 short   
 9    183 tall    
10    182 tall    
# ℹ 77 more rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("if_else", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("join_by")
> ### * join_by
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: join_by
> ### Title: Join specifications
> ### Aliases: join_by closest overlaps within
> 
> ### ** Examples
> 
> sales <- tibble(
+   id = c(1L, 1L, 1L, 2L, 2L),
+   sale_date = as.Date(c("2018-12-31", "2019-01-02", "2019-01-05", "2019-01-04", "2019-01-01"))
+ )
> sales
# A tibble: 5 × 2
     id sale_date 
  <int> <date>    
1     1 2018-12-31
2     1 2019-01-02
3     1 2019-01-05
4     2 2019-01-04
5     2 2019-01-01
> 
> promos <- tibble(
+   id = c(1L, 1L, 2L),
+   promo_date = as.Date(c("2019-01-01", "2019-01-05", "2019-01-02"))
+ )
> promos
# A tibble: 3 × 2
     id promo_date
  <int> <date>    
1     1 2019-01-01
2     1 2019-01-05
3     2 2019-01-02
> 
> # Match `id` to `id`, and `sale_date` to `promo_date`
> by <- join_by(id, sale_date == promo_date)
> left_join(sales, promos, by)
# A tibble: 5 × 2
     id sale_date 
  <int> <date>    
1     1 2018-12-31
2     1 2019-01-02
3     1 2019-01-05
4     2 2019-01-04
5     2 2019-01-01
> 
> # For each `sale_date` within a particular `id`,
> # find all `promo_date`s that occurred before that particular sale
> by <- join_by(id, sale_date >= promo_date)
> left_join(sales, promos, by)
# A tibble: 6 × 3
     id sale_date  promo_date
  <int> <date>     <date>    
1     1 2018-12-31 NA        
2     1 2019-01-02 2019-01-01
3     1 2019-01-05 2019-01-01
4     1 2019-01-05 2019-01-05
5     2 2019-01-04 2019-01-02
6     2 2019-01-01 NA        
> 
> # For each `sale_date` within a particular `id`,
> # find only the closest `promo_date` that occurred before that sale
> by <- join_by(id, closest(sale_date >= promo_date))
> left_join(sales, promos, by)
# A tibble: 5 × 3
     id sale_date  promo_date
  <int> <date>     <date>    
1     1 2018-12-31 NA        
2     1 2019-01-02 2019-01-01
3     1 2019-01-05 2019-01-05
4     2 2019-01-04 2019-01-02
5     2 2019-01-01 NA        
> 
> # If you want to disallow exact matching in rolling joins, use `>` rather
> # than `>=`. Note that the promo on `2019-01-05` is no longer considered the
> # closest match for the sale on the same date.
> by <- join_by(id, closest(sale_date > promo_date))
> left_join(sales, promos, by)
# A tibble: 5 × 3
     id sale_date  promo_date
  <int> <date>     <date>    
1     1 2018-12-31 NA        
2     1 2019-01-02 2019-01-01
3     1 2019-01-05 2019-01-01
4     2 2019-01-04 2019-01-02
5     2 2019-01-01 NA        
> 
> # Same as before, but also require that the promo had to occur at most 1
> # day before the sale was made. We'll use a full join to see that id 2's
> # promo on `2019-01-02` is no longer matched to the sale on `2019-01-04`.
> sales <- mutate(sales, sale_date_lower = sale_date - 1)
> by <- join_by(id, closest(sale_date >= promo_date), sale_date_lower <= promo_date)
> full_join(sales, promos, by)
# A tibble: 6 × 4
     id sale_date  sale_date_lower promo_date
  <int> <date>     <date>          <date>    
1     1 2018-12-31 2018-12-30      NA        
2     1 2019-01-02 2019-01-01      2019-01-01
3     1 2019-01-05 2019-01-04      2019-01-05
4     2 2019-01-04 2019-01-03      NA        
5     2 2019-01-01 2018-12-31      NA        
6     2 NA         NA              2019-01-02
> 
> # ---------------------------------------------------------------------------
> 
> segments <- tibble(
+   segment_id = 1:4,
+   chromosome = c("chr1", "chr2", "chr2", "chr1"),
+   start = c(140, 210, 380, 230),
+   end = c(150, 240, 415, 280)
+ )
> segments
# A tibble: 4 × 4
  segment_id chromosome start   end
       <int> <chr>      <dbl> <dbl>
1          1 chr1         140   150
2          2 chr2         210   240
3          3 chr2         380   415
4          4 chr1         230   280
> 
> reference <- tibble(
+   reference_id = 1:4,
+   chromosome = c("chr1", "chr1", "chr2", "chr2"),
+   start = c(100, 200, 300, 415),
+   end = c(150, 250, 399, 450)
+ )
> reference
# A tibble: 4 × 4
  reference_id chromosome start   end
         <int> <chr>      <dbl> <dbl>
1            1 chr1         100   150
2            2 chr1         200   250
3            3 chr2         300   399
4            4 chr2         415   450
> 
> # Find every time a segment `start` falls between the reference
> # `[start, end]` range.
> by <- join_by(chromosome, between(start, start, end))
> full_join(segments, reference, by)
# A tibble: 5 × 7
  segment_id chromosome start.x end.x reference_id start.y end.y
       <int> <chr>        <dbl> <dbl>        <int>   <dbl> <dbl>
1          1 chr1           140   150            1     100   150
2          2 chr2           210   240           NA      NA    NA
3          3 chr2           380   415            3     300   399
4          4 chr1           230   280            2     200   250
5         NA chr2            NA    NA            4     415   450
> 
> # If you wanted the reference columns first, supply `reference` as `x`
> # and `segments` as `y`, then explicitly refer to their columns using `x$`
> # and `y$`.
> by <- join_by(chromosome, between(y$start, x$start, x$end))
> full_join(reference, segments, by)
# A tibble: 5 × 7
  reference_id chromosome start.x end.x segment_id start.y end.y
         <int> <chr>        <dbl> <dbl>      <int>   <dbl> <dbl>
1            1 chr1           100   150          1     140   150
2            2 chr1           200   250          4     230   280
3            3 chr2           300   399          3     380   415
4            4 chr2           415   450         NA      NA    NA
5           NA chr2            NA    NA          2     210   240
> 
> # Find every time a segment falls completely within a reference.
> # Sometimes using `x$` and `y$` makes your intentions clearer, even if they
> # match the default behavior.
> by <- join_by(chromosome, within(x$start, x$end, y$start, y$end))
> inner_join(segments, reference, by)
# A tibble: 1 × 7
  segment_id chromosome start.x end.x reference_id start.y end.y
       <int> <chr>        <dbl> <dbl>        <int>   <dbl> <dbl>
1          1 chr1           140   150            1     100   150
> 
> # Find every time a segment overlaps a reference in any way.
> by <- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end))
> full_join(segments, reference, by)
# A tibble: 5 × 7
  segment_id chromosome start.x end.x reference_id start.y end.y
       <int> <chr>        <dbl> <dbl>        <int>   <dbl> <dbl>
1          1 chr1           140   150            1     100   150
2          2 chr2           210   240           NA      NA    NA
3          3 chr2           380   415            3     300   399
4          3 chr2           380   415            4     415   450
5          4 chr1           230   280            2     200   250
> 
> # It is common to have right-open ranges with bounds like `[)`, which would
> # mean an end value of `415` would no longer overlap a start value of `415`.
> # Setting `bounds` allows you to compute overlaps with those kinds of ranges.
> by <- join_by(chromosome, overlaps(x$start, x$end, y$start, y$end, bounds = "[)"))
> full_join(segments, reference, by)
# A tibble: 5 × 7
  segment_id chromosome start.x end.x reference_id start.y end.y
       <int> <chr>        <dbl> <dbl>        <int>   <dbl> <dbl>
1          1 chr1           140   150            1     100   150
2          2 chr2           210   240           NA      NA    NA
3          3 chr2           380   415            3     300   399
4          4 chr1           230   280            2     200   250
5         NA chr2            NA    NA            4     415   450
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("join_by", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("lead-lag")
> ### * lead-lag
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lead-lag
> ### Title: Compute lagged or leading values
> ### Aliases: lead-lag lag lead
> 
> ### ** Examples
> 
> lag(1:5)
[1] NA  1  2  3  4
> lead(1:5)
[1]  2  3  4  5 NA
> 
> x <- 1:5
> tibble(behind = lag(x), x, ahead = lead(x))
# A tibble: 5 × 3
  behind     x ahead
   <int> <int> <int>
1     NA     1     2
2      1     2     3
3      2     3     4
4      3     4     5
5      4     5    NA
> 
> # If you want to look more rows behind or ahead, use `n`
> lag(1:5, n = 1)
[1] NA  1  2  3  4
> lag(1:5, n = 2)
[1] NA NA  1  2  3
> 
> lead(1:5, n = 1)
[1]  2  3  4  5 NA
> lead(1:5, n = 2)
[1]  3  4  5 NA NA
> 
> # If you want to define a value to pad with, use `default`
> lag(1:5)
[1] NA  1  2  3  4
> lag(1:5, default = 0)
[1] 0 1 2 3 4
> 
> lead(1:5)
[1]  2  3  4  5 NA
> lead(1:5, default = 6)
[1] 2 3 4 5 6
> 
> # If the data are not already ordered, use `order_by`
> scrambled <- slice_sample(
+   tibble(year = 2000:2005, value = (0:5) ^ 2),
+   prop = 1
+ )
> 
> wrong <- mutate(scrambled, previous_year_value = lag(value))
> arrange(wrong, year)
# A tibble: 6 × 3
   year value previous_year_value
  <int> <dbl>               <dbl>
1  2000     0                  NA
2  2001     1                  25
3  2002     4                   9
4  2003     9                   0
5  2004    16                   1
6  2005    25                   4
> 
> right <- mutate(scrambled, previous_year_value = lag(value, order_by = year))
> arrange(right, year)
# A tibble: 6 × 3
   year value previous_year_value
  <int> <dbl>               <dbl>
1  2000     0                  NA
2  2001     1                   0
3  2002     4                   1
4  2003     9                   4
5  2004    16                   9
6  2005    25                  16
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lead-lag", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mutate-joins")
> ### * mutate-joins
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mutate-joins
> ### Title: Mutating joins
> ### Aliases: mutate-joins join join.data.frame inner_join
> ###   inner_join.data.frame left_join left_join.data.frame right_join
> ###   right_join.data.frame full_join full_join.data.frame
> 
> ### ** Examples
> 
> band_members %>% inner_join(band_instruments)
Joining with `by = join_by(name)`
# A tibble: 2 × 3
  name  band    plays 
  <chr> <chr>   <chr> 
1 John  Beatles guitar
2 Paul  Beatles bass  
> band_members %>% left_join(band_instruments)
Joining with `by = join_by(name)`
# A tibble: 3 × 3
  name  band    plays 
  <chr> <chr>   <chr> 
1 Mick  Stones  <NA>  
2 John  Beatles guitar
3 Paul  Beatles bass  
> band_members %>% right_join(band_instruments)
Joining with `by = join_by(name)`
# A tibble: 3 × 3
  name  band    plays 
  <chr> <chr>   <chr> 
1 John  Beatles guitar
2 Paul  Beatles bass  
3 Keith <NA>    guitar
> band_members %>% full_join(band_instruments)
Joining with `by = join_by(name)`
# A tibble: 4 × 3
  name  band    plays 
  <chr> <chr>   <chr> 
1 Mick  Stones  <NA>  
2 John  Beatles guitar
3 Paul  Beatles bass  
4 Keith <NA>    guitar
> 
> # To suppress the message about joining variables, supply `by`
> band_members %>% inner_join(band_instruments, by = join_by(name))
# A tibble: 2 × 3
  name  band    plays 
  <chr> <chr>   <chr> 
1 John  Beatles guitar
2 Paul  Beatles bass  
> # This is good practice in production code
> 
> # Use an equality expression if the join variables have different names
> band_members %>% full_join(band_instruments2, by = join_by(name == artist))
# A tibble: 4 × 3
  name  band    plays 
  <chr> <chr>   <chr> 
1 Mick  Stones  <NA>  
2 John  Beatles guitar
3 Paul  Beatles bass  
4 Keith <NA>    guitar
> # By default, the join keys from `x` and `y` are coalesced in the output; use
> # `keep = TRUE` to keep the join keys from both `x` and `y`
> band_members %>%
+   full_join(band_instruments2, by = join_by(name == artist), keep = TRUE)
# A tibble: 4 × 4
  name  band    artist plays 
  <chr> <chr>   <chr>  <chr> 
1 Mick  Stones  <NA>   <NA>  
2 John  Beatles John   guitar
3 Paul  Beatles Paul   bass  
4 <NA>  <NA>    Keith  guitar
> 
> # If a row in `x` matches multiple rows in `y`, all the rows in `y` will be
> # returned once for each matching row in `x`.
> df1 <- tibble(x = 1:3)
> df2 <- tibble(x = c(1, 1, 2), y = c("first", "second", "third"))
> df1 %>% left_join(df2)
Joining with `by = join_by(x)`
# A tibble: 4 × 2
      x y     
  <dbl> <chr> 
1     1 first 
2     1 second
3     2 third 
4     3 <NA>  
> 
> # If a row in `y` also matches multiple rows in `x`, this is known as a
> # many-to-many relationship, which is typically a result of an improperly
> # specified join or some kind of messy data. In this case, a warning is
> # thrown by default:
> df3 <- tibble(x = c(1, 1, 1, 3))
> df3 %>% left_join(df2)
Joining with `by = join_by(x)`
Warning in left_join(., df2) :
  Detected an unexpected many-to-many relationship between `x` and `y`.
ℹ Row 1 of `x` matches multiple rows in `y`.
ℹ Row 1 of `y` matches multiple rows in `x`.
ℹ If a many-to-many relationship is expected, set `relationship =
  "many-to-many"` to silence this warning.
# A tibble: 7 × 2
      x y     
  <dbl> <chr> 
1     1 first 
2     1 second
3     1 first 
4     1 second
5     1 first 
6     1 second
7     3 <NA>  
> 
> # In the rare case where a many-to-many relationship is expected, set
> # `relationship = "many-to-many"` to silence this warning
> df3 %>% left_join(df2, relationship = "many-to-many")
Joining with `by = join_by(x)`
# A tibble: 7 × 2
      x y     
  <dbl> <chr> 
1     1 first 
2     1 second
3     1 first 
4     1 second
5     1 first 
6     1 second
7     3 <NA>  
> 
> # Use `join_by()` with a condition other than `==` to perform an inequality
> # join. Here we match on every instance where `df1$x > df2$x`.
> df1 %>% left_join(df2, join_by(x > x))
# A tibble: 6 × 3
    x.x   x.y y     
  <int> <dbl> <chr> 
1     1    NA <NA>  
2     2     1 first 
3     2     1 second
4     3     1 first 
5     3     1 second
6     3     2 third 
> 
> # By default, NAs match other NAs so that there are two
> # rows in the output of this join:
> df1 <- data.frame(x = c(1, NA), y = 2)
> df2 <- data.frame(x = c(1, NA), z = 3)
> left_join(df1, df2)
Joining with `by = join_by(x)`
   x y z
1  1 2 3
2 NA 2 3
> 
> # You can optionally request that NAs don't match, giving a
> # a result that more closely resembles SQL joins
> left_join(df1, df2, na_matches = "never")
Joining with `by = join_by(x)`
   x y  z
1  1 2  3
2 NA 2 NA
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mutate-joins", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mutate")
> ### * mutate
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mutate
> ### Title: Create, modify, and delete columns
> ### Aliases: mutate mutate.data.frame
> 
> ### ** Examples
> 
> # Newly created variables are available immediately
> starwars %>%
+   select(name, mass) %>%
+   mutate(
+     mass2 = mass * 2,
+     mass2_squared = mass2 * mass2
+   )
# A tibble: 87 × 4
   name                mass mass2 mass2_squared
   <chr>              <dbl> <dbl>         <dbl>
 1 Luke Skywalker        77   154         23716
 2 C-3PO                 75   150         22500
 3 R2-D2                 32    64          4096
 4 Darth Vader          136   272         73984
 5 Leia Organa           49    98          9604
 6 Owen Lars            120   240         57600
 7 Beru Whitesun Lars    75   150         22500
 8 R5-D4                 32    64          4096
 9 Biggs Darklighter     84   168         28224
10 Obi-Wan Kenobi        77   154         23716
# ℹ 77 more rows
> 
> # As well as adding new variables, you can use mutate() to
> # remove variables and modify existing variables.
> starwars %>%
+   select(name, height, mass, homeworld) %>%
+   mutate(
+     mass = NULL,
+     height = height * 0.0328084 # convert to feet
+   )
# A tibble: 87 × 3
   name               height homeworld
   <chr>               <dbl> <chr>    
 1 Luke Skywalker       5.64 Tatooine 
 2 C-3PO                5.48 Tatooine 
 3 R2-D2                3.15 Naboo    
 4 Darth Vader          6.63 Tatooine 
 5 Leia Organa          4.92 Alderaan 
 6 Owen Lars            5.84 Tatooine 
 7 Beru Whitesun Lars   5.41 Tatooine 
 8 R5-D4                3.18 Tatooine 
 9 Biggs Darklighter    6.00 Tatooine 
10 Obi-Wan Kenobi       5.97 Stewjon  
# ℹ 77 more rows
> 
> # Use across() with mutate() to apply a transformation
> # to multiple columns in a tibble.
> starwars %>%
+   select(name, homeworld, species) %>%
+   mutate(across(!name, as.factor))
# A tibble: 87 × 3
   name               homeworld species
   <chr>              <fct>     <fct>  
 1 Luke Skywalker     Tatooine  Human  
 2 C-3PO              Tatooine  Droid  
 3 R2-D2              Naboo     Droid  
 4 Darth Vader        Tatooine  Human  
 5 Leia Organa        Alderaan  Human  
 6 Owen Lars          Tatooine  Human  
 7 Beru Whitesun Lars Tatooine  Human  
 8 R5-D4              Tatooine  Droid  
 9 Biggs Darklighter  Tatooine  Human  
10 Obi-Wan Kenobi     Stewjon   Human  
# ℹ 77 more rows
> # see more in ?across
> 
> # Window functions are useful for grouped mutates:
> starwars %>%
+   select(name, mass, homeworld) %>%
+   group_by(homeworld) %>%
+   mutate(rank = min_rank(desc(mass)))
# A tibble: 87 × 4
# Groups:   homeworld [49]
   name                mass homeworld  rank
   <chr>              <dbl> <chr>     <int>
 1 Luke Skywalker        77 Tatooine      5
 2 C-3PO                 75 Tatooine      6
 3 R2-D2                 32 Naboo         6
 4 Darth Vader          136 Tatooine      1
 5 Leia Organa           49 Alderaan      2
 6 Owen Lars            120 Tatooine      2
 7 Beru Whitesun Lars    75 Tatooine      6
 8 R5-D4                 32 Tatooine      8
 9 Biggs Darklighter     84 Tatooine      3
10 Obi-Wan Kenobi        77 Stewjon       1
# ℹ 77 more rows
> # see `vignette("window-functions")` for more details
> 
> # By default, new columns are placed on the far right.
> df <- tibble(x = 1, y = 2)
> df %>% mutate(z = x + y)
# A tibble: 1 × 3
      x     y     z
  <dbl> <dbl> <dbl>
1     1     2     3
> df %>% mutate(z = x + y, .before = 1)
# A tibble: 1 × 3
      z     x     y
  <dbl> <dbl> <dbl>
1     3     1     2
> df %>% mutate(z = x + y, .after = x)
# A tibble: 1 × 3
      x     z     y
  <dbl> <dbl> <dbl>
1     1     3     2
> 
> # By default, mutate() keeps all columns from the input data.
> df <- tibble(x = 1, y = 2, a = "a", b = "b")
> df %>% mutate(z = x + y, .keep = "all") # the default
# A tibble: 1 × 5
      x     y a     b         z
  <dbl> <dbl> <chr> <chr> <dbl>
1     1     2 a     b         3
> df %>% mutate(z = x + y, .keep = "used")
# A tibble: 1 × 3
      x     y     z
  <dbl> <dbl> <dbl>
1     1     2     3
> df %>% mutate(z = x + y, .keep = "unused")
# A tibble: 1 × 3
  a     b         z
  <chr> <chr> <dbl>
1 a     b         3
> df %>% mutate(z = x + y, .keep = "none")
# A tibble: 1 × 1
      z
  <dbl>
1     3
> 
> # Grouping ----------------------------------------
> # The mutate operation may yield different results on grouped
> # tibbles because the expressions are computed within groups.
> # The following normalises `mass` by the global average:
> starwars %>%
+   select(name, mass, species) %>%
+   mutate(mass_norm = mass / mean(mass, na.rm = TRUE))
# A tibble: 87 × 4
   name                mass species mass_norm
   <chr>              <dbl> <chr>       <dbl>
 1 Luke Skywalker        77 Human       0.791
 2 C-3PO                 75 Droid       0.771
 3 R2-D2                 32 Droid       0.329
 4 Darth Vader          136 Human       1.40 
 5 Leia Organa           49 Human       0.504
 6 Owen Lars            120 Human       1.23 
 7 Beru Whitesun Lars    75 Human       0.771
 8 R5-D4                 32 Droid       0.329
 9 Biggs Darklighter     84 Human       0.863
10 Obi-Wan Kenobi        77 Human       0.791
# ℹ 77 more rows
> 
> # Whereas this normalises `mass` by the averages within species
> # levels:
> starwars %>%
+   select(name, mass, species) %>%
+   group_by(species) %>%
+   mutate(mass_norm = mass / mean(mass, na.rm = TRUE))
# A tibble: 87 × 4
# Groups:   species [38]
   name                mass species mass_norm
   <chr>              <dbl> <chr>       <dbl>
 1 Luke Skywalker        77 Human       0.947
 2 C-3PO                 75 Droid       1.08 
 3 R2-D2                 32 Droid       0.459
 4 Darth Vader          136 Human       1.67 
 5 Leia Organa           49 Human       0.603
 6 Owen Lars            120 Human       1.48 
 7 Beru Whitesun Lars    75 Human       0.922
 8 R5-D4                 32 Droid       0.459
 9 Biggs Darklighter     84 Human       1.03 
10 Obi-Wan Kenobi        77 Human       0.947
# ℹ 77 more rows
> 
> # Indirection ----------------------------------------
> # Refer to column names stored as strings with the `.data` pronoun:
> vars <- c("mass", "height")
> mutate(starwars, prod = .data[[vars[[1]]]] * .data[[vars[[2]]]])
# A tibble: 87 × 15
   name     height  mass hair_color skin_color eye_color birth_year sex   gender
   <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…
 2 C-3PO       167    75 <NA>       gold       yellow         112   none  mascu…
 3 R2-D2        96    32 <NA>       white, bl… red             33   none  mascu…
 4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
 5 Leia Or…    150    49 brown      light      brown           19   fema… femin…
 6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
 7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…
 8 R5-D4        97    32 <NA>       white, red red             NA   none  mascu…
 9 Biggs D…    183    84 black      light      brown           24   male  mascu…
10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…
# ℹ 77 more rows
# ℹ 6 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>, prod <dbl>
> # Learn more in ?rlang::args_data_masking
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mutate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mutate_all")
> ### * mutate_all
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mutate_all
> ### Title: Mutate multiple columns
> ### Aliases: mutate_all mutate_if mutate_at transmute_all transmute_if
> ###   transmute_at
> ### Keywords: internal
> 
> ### ** Examples
> 
> iris <- as_tibble(iris)
> 
> # All variants can be passed functions and additional arguments,
> # purrr-style. The _at() variants directly support strings. Here
> # we'll scale the variables `height` and `mass`:
> scale2 <- function(x, na.rm = FALSE) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)
> starwars %>% mutate_at(c("height", "mass"), scale2)
# A tibble: 87 × 14
   name     height  mass hair_color skin_color eye_color birth_year sex   gender
   <chr>     <dbl> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke Sk…     NA    NA blond      fair       blue            19   male  mascu…
 2 C-3PO        NA    NA <NA>       gold       yellow         112   none  mascu…
 3 R2-D2        NA    NA <NA>       white, bl… red             33   none  mascu…
 4 Darth V…     NA    NA none       white      yellow          41.9 male  mascu…
 5 Leia Or…     NA    NA brown      light      brown           19   fema… femin…
 6 Owen La…     NA    NA brown, gr… light      blue            52   male  mascu…
 7 Beru Wh…     NA    NA brown      light      blue            47   fema… femin…
 8 R5-D4        NA    NA <NA>       white, red red             NA   none  mascu…
 9 Biggs D…     NA    NA black      light      brown           24   male  mascu…
10 Obi-Wan…     NA    NA auburn, w… fair       blue-gray       57   male  mascu…
# ℹ 77 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> # ->
> starwars %>% mutate(across(c("height", "mass"), scale2))
# A tibble: 87 × 14
   name     height  mass hair_color skin_color eye_color birth_year sex   gender
   <chr>     <dbl> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke Sk…     NA    NA blond      fair       blue            19   male  mascu…
 2 C-3PO        NA    NA <NA>       gold       yellow         112   none  mascu…
 3 R2-D2        NA    NA <NA>       white, bl… red             33   none  mascu…
 4 Darth V…     NA    NA none       white      yellow          41.9 male  mascu…
 5 Leia Or…     NA    NA brown      light      brown           19   fema… femin…
 6 Owen La…     NA    NA brown, gr… light      blue            52   male  mascu…
 7 Beru Wh…     NA    NA brown      light      blue            47   fema… femin…
 8 R5-D4        NA    NA <NA>       white, red red             NA   none  mascu…
 9 Biggs D…     NA    NA black      light      brown           24   male  mascu…
10 Obi-Wan…     NA    NA auburn, w… fair       blue-gray       57   male  mascu…
# ℹ 77 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> # You can pass additional arguments to the function:
> starwars %>% mutate_at(c("height", "mass"), scale2, na.rm = TRUE)
# A tibble: 87 × 14
   name   height    mass hair_color skin_color eye_color birth_year sex   gender
   <chr>   <dbl>   <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke… -0.0749 -0.120  blond      fair       blue            19   male  mascu…
 2 C-3PO -0.219  -0.132  <NA>       gold       yellow         112   none  mascu…
 3 R2-D2 -2.26   -0.385  <NA>       white, bl… red             33   none  mascu…
 4 Dart…  0.788   0.228  none       white      yellow          41.9 male  mascu…
 5 Leia… -0.708  -0.285  brown      light      brown           19   fema… femin…
 6 Owen…  0.0976  0.134  brown, gr… light      blue            52   male  mascu…
 7 Beru… -0.276  -0.132  brown      light      blue            47   fema… femin…
 8 R5-D4 -2.23   -0.385  <NA>       white, red red             NA   none  mascu…
 9 Bigg…  0.241  -0.0786 black      light      brown           24   male  mascu…
10 Obi-…  0.213  -0.120  auburn, w… fair       blue-gray       57   male  mascu…
# ℹ 77 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> starwars %>% mutate_at(c("height", "mass"), ~scale2(., na.rm = TRUE))
# A tibble: 87 × 14
   name   height    mass hair_color skin_color eye_color birth_year sex   gender
   <chr>   <dbl>   <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke… -0.0749 -0.120  blond      fair       blue            19   male  mascu…
 2 C-3PO -0.219  -0.132  <NA>       gold       yellow         112   none  mascu…
 3 R2-D2 -2.26   -0.385  <NA>       white, bl… red             33   none  mascu…
 4 Dart…  0.788   0.228  none       white      yellow          41.9 male  mascu…
 5 Leia… -0.708  -0.285  brown      light      brown           19   fema… femin…
 6 Owen…  0.0976  0.134  brown, gr… light      blue            52   male  mascu…
 7 Beru… -0.276  -0.132  brown      light      blue            47   fema… femin…
 8 R5-D4 -2.23   -0.385  <NA>       white, red red             NA   none  mascu…
 9 Bigg…  0.241  -0.0786 black      light      brown           24   male  mascu…
10 Obi-…  0.213  -0.120  auburn, w… fair       blue-gray       57   male  mascu…
# ℹ 77 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> # ->
> starwars %>% mutate(across(c("height", "mass"), ~ scale2(.x, na.rm = TRUE)))
# A tibble: 87 × 14
   name   height    mass hair_color skin_color eye_color birth_year sex   gender
   <chr>   <dbl>   <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke… -0.0749 -0.120  blond      fair       blue            19   male  mascu…
 2 C-3PO -0.219  -0.132  <NA>       gold       yellow         112   none  mascu…
 3 R2-D2 -2.26   -0.385  <NA>       white, bl… red             33   none  mascu…
 4 Dart…  0.788   0.228  none       white      yellow          41.9 male  mascu…
 5 Leia… -0.708  -0.285  brown      light      brown           19   fema… femin…
 6 Owen…  0.0976  0.134  brown, gr… light      blue            52   male  mascu…
 7 Beru… -0.276  -0.132  brown      light      blue            47   fema… femin…
 8 R5-D4 -2.23   -0.385  <NA>       white, red red             NA   none  mascu…
 9 Bigg…  0.241  -0.0786 black      light      brown           24   male  mascu…
10 Obi-…  0.213  -0.120  auburn, w… fair       blue-gray       57   male  mascu…
# ℹ 77 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> # You can also supply selection helpers to _at() functions but you have
> # to quote them with vars():
> iris %>% mutate_at(vars(matches("Sepal")), log)
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1         1.63        1.25          1.4         0.2 setosa 
 2         1.59        1.10          1.4         0.2 setosa 
 3         1.55        1.16          1.3         0.2 setosa 
 4         1.53        1.13          1.5         0.2 setosa 
 5         1.61        1.28          1.4         0.2 setosa 
 6         1.69        1.36          1.7         0.4 setosa 
 7         1.53        1.22          1.4         0.3 setosa 
 8         1.61        1.22          1.5         0.2 setosa 
 9         1.48        1.06          1.4         0.2 setosa 
10         1.59        1.13          1.5         0.1 setosa 
# ℹ 140 more rows
> iris %>% mutate(across(matches("Sepal"), log))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1         1.63        1.25          1.4         0.2 setosa 
 2         1.59        1.10          1.4         0.2 setosa 
 3         1.55        1.16          1.3         0.2 setosa 
 4         1.53        1.13          1.5         0.2 setosa 
 5         1.61        1.28          1.4         0.2 setosa 
 6         1.69        1.36          1.7         0.4 setosa 
 7         1.53        1.22          1.4         0.3 setosa 
 8         1.61        1.22          1.5         0.2 setosa 
 9         1.48        1.06          1.4         0.2 setosa 
10         1.59        1.13          1.5         0.1 setosa 
# ℹ 140 more rows
> 
> # The _if() variants apply a predicate function (a function that
> # returns TRUE or FALSE) to determine the relevant subset of
> # columns. Here we divide all the numeric columns by 100:
> starwars %>% mutate_if(is.numeric, scale2, na.rm = TRUE)
# A tibble: 87 × 14
   name   height    mass hair_color skin_color eye_color birth_year sex   gender
   <chr>   <dbl>   <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke… -0.0749 -0.120  blond      fair       blue          -0.443 male  mascu…
 2 C-3PO -0.219  -0.132  <NA>       gold       yellow         0.158 none  mascu…
 3 R2-D2 -2.26   -0.385  <NA>       white, bl… red           -0.353 none  mascu…
 4 Dart…  0.788   0.228  none       white      yellow        -0.295 male  mascu…
 5 Leia… -0.708  -0.285  brown      light      brown         -0.443 fema… femin…
 6 Owen…  0.0976  0.134  brown, gr… light      blue          -0.230 male  mascu…
 7 Beru… -0.276  -0.132  brown      light      blue          -0.262 fema… femin…
 8 R5-D4 -2.23   -0.385  <NA>       white, red red           NA     none  mascu…
 9 Bigg…  0.241  -0.0786 black      light      brown         -0.411 male  mascu…
10 Obi-…  0.213  -0.120  auburn, w… fair       blue-gray     -0.198 male  mascu…
# ℹ 77 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> starwars %>% mutate(across(where(is.numeric), ~ scale2(.x, na.rm = TRUE)))
# A tibble: 87 × 14
   name   height    mass hair_color skin_color eye_color birth_year sex   gender
   <chr>   <dbl>   <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke… -0.0749 -0.120  blond      fair       blue          -0.443 male  mascu…
 2 C-3PO -0.219  -0.132  <NA>       gold       yellow         0.158 none  mascu…
 3 R2-D2 -2.26   -0.385  <NA>       white, bl… red           -0.353 none  mascu…
 4 Dart…  0.788   0.228  none       white      yellow        -0.295 male  mascu…
 5 Leia… -0.708  -0.285  brown      light      brown         -0.443 fema… femin…
 6 Owen…  0.0976  0.134  brown, gr… light      blue          -0.230 male  mascu…
 7 Beru… -0.276  -0.132  brown      light      blue          -0.262 fema… femin…
 8 R5-D4 -2.23   -0.385  <NA>       white, red red           NA     none  mascu…
 9 Bigg…  0.241  -0.0786 black      light      brown         -0.411 male  mascu…
10 Obi-…  0.213  -0.120  auburn, w… fair       blue-gray     -0.198 male  mascu…
# ℹ 77 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> # mutate_if() is particularly useful for transforming variables from
> # one type to another
> iris %>% mutate_if(is.factor, as.character)
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <chr>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> iris %>% mutate_if(is.double, as.integer)
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <int>       <int>        <int>       <int> <fct>  
 1            5           3            1           0 setosa 
 2            4           3            1           0 setosa 
 3            4           3            1           0 setosa 
 4            4           3            1           0 setosa 
 5            5           3            1           0 setosa 
 6            5           3            1           0 setosa 
 7            4           3            1           0 setosa 
 8            5           3            1           0 setosa 
 9            4           2            1           0 setosa 
10            4           3            1           0 setosa 
# ℹ 140 more rows
> # ->
> iris %>% mutate(across(where(is.factor), as.character))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <chr>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> iris %>% mutate(across(where(is.double), as.integer))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <int>       <int>        <int>       <int> <fct>  
 1            5           3            1           0 setosa 
 2            4           3            1           0 setosa 
 3            4           3            1           0 setosa 
 4            4           3            1           0 setosa 
 5            5           3            1           0 setosa 
 6            5           3            1           0 setosa 
 7            4           3            1           0 setosa 
 8            5           3            1           0 setosa 
 9            4           2            1           0 setosa 
10            4           3            1           0 setosa 
# ℹ 140 more rows
> 
> # Multiple transformations ----------------------------------------
> 
> # If you want to apply multiple transformations, pass a list of
> # functions. When there are multiple functions, they create new
> # variables instead of modifying the variables in place:
> iris %>% mutate_if(is.numeric, list(scale2, log))
# A tibble: 150 × 13
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Length_fn1
          <dbl>       <dbl>        <dbl>       <dbl> <fct>              <dbl>
 1          5.1         3.5          1.4         0.2 setosa            -0.898
 2          4.9         3            1.4         0.2 setosa            -1.14 
 3          4.7         3.2          1.3         0.2 setosa            -1.38 
 4          4.6         3.1          1.5         0.2 setosa            -1.50 
 5          5           3.6          1.4         0.2 setosa            -1.02 
 6          5.4         3.9          1.7         0.4 setosa            -0.535
 7          4.6         3.4          1.4         0.3 setosa            -1.50 
 8          5           3.4          1.5         0.2 setosa            -1.02 
 9          4.4         2.9          1.4         0.2 setosa            -1.74 
10          4.9         3.1          1.5         0.1 setosa            -1.14 
# ℹ 140 more rows
# ℹ 7 more variables: Sepal.Width_fn1 <dbl>, Petal.Length_fn1 <dbl>,
#   Petal.Width_fn1 <dbl>, Sepal.Length_fn2 <dbl>, Sepal.Width_fn2 <dbl>,
#   Petal.Length_fn2 <dbl>, Petal.Width_fn2 <dbl>
> iris %>% mutate_if(is.numeric, list(~scale2(.), ~log(.)))
# A tibble: 150 × 13
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Length_scale2
          <dbl>       <dbl>        <dbl>       <dbl> <fct>                 <dbl>
 1          5.1         3.5          1.4         0.2 setosa               -0.898
 2          4.9         3            1.4         0.2 setosa               -1.14 
 3          4.7         3.2          1.3         0.2 setosa               -1.38 
 4          4.6         3.1          1.5         0.2 setosa               -1.50 
 5          5           3.6          1.4         0.2 setosa               -1.02 
 6          5.4         3.9          1.7         0.4 setosa               -0.535
 7          4.6         3.4          1.4         0.3 setosa               -1.50 
 8          5           3.4          1.5         0.2 setosa               -1.02 
 9          4.4         2.9          1.4         0.2 setosa               -1.74 
10          4.9         3.1          1.5         0.1 setosa               -1.14 
# ℹ 140 more rows
# ℹ 7 more variables: Sepal.Width_scale2 <dbl>, Petal.Length_scale2 <dbl>,
#   Petal.Width_scale2 <dbl>, Sepal.Length_log <dbl>, Sepal.Width_log <dbl>,
#   Petal.Length_log <dbl>, Petal.Width_log <dbl>
> iris %>% mutate_if(is.numeric, list(scale = scale2, log = log))
# A tibble: 150 × 13
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Length_scale
          <dbl>       <dbl>        <dbl>       <dbl> <fct>                <dbl>
 1          5.1         3.5          1.4         0.2 setosa              -0.898
 2          4.9         3            1.4         0.2 setosa              -1.14 
 3          4.7         3.2          1.3         0.2 setosa              -1.38 
 4          4.6         3.1          1.5         0.2 setosa              -1.50 
 5          5           3.6          1.4         0.2 setosa              -1.02 
 6          5.4         3.9          1.7         0.4 setosa              -0.535
 7          4.6         3.4          1.4         0.3 setosa              -1.50 
 8          5           3.4          1.5         0.2 setosa              -1.02 
 9          4.4         2.9          1.4         0.2 setosa              -1.74 
10          4.9         3.1          1.5         0.1 setosa              -1.14 
# ℹ 140 more rows
# ℹ 7 more variables: Sepal.Width_scale <dbl>, Petal.Length_scale <dbl>,
#   Petal.Width_scale <dbl>, Sepal.Length_log <dbl>, Sepal.Width_log <dbl>,
#   Petal.Length_log <dbl>, Petal.Width_log <dbl>
> # ->
> iris %>%
+   as_tibble() %>%
+   mutate(across(where(is.numeric), list(scale = scale2, log = log)))
# A tibble: 150 × 13
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Length_scale
          <dbl>       <dbl>        <dbl>       <dbl> <fct>                <dbl>
 1          5.1         3.5          1.4         0.2 setosa              -0.898
 2          4.9         3            1.4         0.2 setosa              -1.14 
 3          4.7         3.2          1.3         0.2 setosa              -1.38 
 4          4.6         3.1          1.5         0.2 setosa              -1.50 
 5          5           3.6          1.4         0.2 setosa              -1.02 
 6          5.4         3.9          1.7         0.4 setosa              -0.535
 7          4.6         3.4          1.4         0.3 setosa              -1.50 
 8          5           3.4          1.5         0.2 setosa              -1.02 
 9          4.4         2.9          1.4         0.2 setosa              -1.74 
10          4.9         3.1          1.5         0.1 setosa              -1.14 
# ℹ 140 more rows
# ℹ 7 more variables: Sepal.Length_log <dbl>, Sepal.Width_scale <dbl>,
#   Sepal.Width_log <dbl>, Petal.Length_scale <dbl>, Petal.Length_log <dbl>,
#   Petal.Width_scale <dbl>, Petal.Width_log <dbl>
> 
> # When there's only one function in the list, it modifies existing
> # variables in place. Give it a name to instead create new variables:
> iris %>% mutate_if(is.numeric, list(scale2))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1       -0.898      1.02          -1.34       -1.31 setosa 
 2       -1.14      -0.132         -1.34       -1.31 setosa 
 3       -1.38       0.327         -1.39       -1.31 setosa 
 4       -1.50       0.0979        -1.28       -1.31 setosa 
 5       -1.02       1.25          -1.34       -1.31 setosa 
 6       -0.535      1.93          -1.17       -1.05 setosa 
 7       -1.50       0.786         -1.34       -1.18 setosa 
 8       -1.02       0.786         -1.28       -1.31 setosa 
 9       -1.74      -0.361         -1.34       -1.31 setosa 
10       -1.14       0.0979        -1.28       -1.44 setosa 
# ℹ 140 more rows
> iris %>% mutate_if(is.numeric, list(scale = scale2))
# A tibble: 150 × 9
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Length_scale
          <dbl>       <dbl>        <dbl>       <dbl> <fct>                <dbl>
 1          5.1         3.5          1.4         0.2 setosa              -0.898
 2          4.9         3            1.4         0.2 setosa              -1.14 
 3          4.7         3.2          1.3         0.2 setosa              -1.38 
 4          4.6         3.1          1.5         0.2 setosa              -1.50 
 5          5           3.6          1.4         0.2 setosa              -1.02 
 6          5.4         3.9          1.7         0.4 setosa              -0.535
 7          4.6         3.4          1.4         0.3 setosa              -1.50 
 8          5           3.4          1.5         0.2 setosa              -1.02 
 9          4.4         2.9          1.4         0.2 setosa              -1.74 
10          4.9         3.1          1.5         0.1 setosa              -1.14 
# ℹ 140 more rows
# ℹ 3 more variables: Sepal.Width_scale <dbl>, Petal.Length_scale <dbl>,
#   Petal.Width_scale <dbl>
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mutate_all", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("n_distinct")
> ### * n_distinct
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: n_distinct
> ### Title: Count unique combinations
> ### Aliases: n_distinct
> 
> ### ** Examples
> 
> x <- c(1, 1, 2, 2, 2)
> n_distinct(x)
[1] 2
> 
> y <- c(3, 3, NA, 3, 3)
> n_distinct(y)
[1] 2
> n_distinct(y, na.rm = TRUE)
[1] 1
> 
> # Pairs (1, 3), (2, 3), and (2, NA) are distinct
> n_distinct(x, y)
[1] 3
> 
> # (2, NA) is dropped, leaving 2 distinct combinations
> n_distinct(x, y, na.rm = TRUE)
[1] 2
> 
> # Also works with data frames
> n_distinct(data.frame(x, y))
[1] 3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("n_distinct", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("na_if")
> ### * na_if
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: na_if
> ### Title: Convert values to 'NA'
> ### Aliases: na_if
> 
> ### ** Examples
> 
> na_if(1:5, 5:1)
[1]  1  2 NA  4  5
> 
> x <- c(1, -1, 0, 10)
> 100 / x
[1]  100 -100  Inf   10
> 100 / na_if(x, 0)
[1]  100 -100   NA   10
> 
> y <- c("abc", "def", "", "ghi")
> na_if(y, "")
[1] "abc" "def" NA    "ghi"
> 
> # `na_if()` allows you to replace `NaN` with `NA`,
> # even though `NaN == NaN` returns `NA`
> z <- c(1, NaN, NA, 2, NaN)
> na_if(z, NaN)
[1]  1 NA NA  2 NA
> 
> # `na_if()` is particularly useful inside `mutate()`,
> # and is meant for use with vectors rather than entire data frames
> starwars %>%
+   select(name, eye_color) %>%
+   mutate(eye_color = na_if(eye_color, "unknown"))
# A tibble: 87 × 2
   name               eye_color
   <chr>              <chr>    
 1 Luke Skywalker     blue     
 2 C-3PO              yellow   
 3 R2-D2              red      
 4 Darth Vader        yellow   
 5 Leia Organa        brown    
 6 Owen Lars          blue     
 7 Beru Whitesun Lars blue     
 8 R5-D4              red      
 9 Biggs Darklighter  brown    
10 Obi-Wan Kenobi     blue-gray
# ℹ 77 more rows
> 
> # `na_if()` can also be used with `mutate()` and `across()`
> # to alter multiple columns
> starwars %>%
+    mutate(across(where(is.character), ~na_if(., "unknown")))
# A tibble: 87 × 14
   name     height  mass hair_color skin_color eye_color birth_year sex   gender
   <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…
 2 C-3PO       167    75 <NA>       gold       yellow         112   none  mascu…
 3 R2-D2        96    32 <NA>       white, bl… red             33   none  mascu…
 4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
 5 Leia Or…    150    49 brown      light      brown           19   fema… femin…
 6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
 7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…
 8 R5-D4        97    32 <NA>       white, red red             NA   none  mascu…
 9 Biggs D…    183    84 black      light      brown           24   male  mascu…
10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…
# ℹ 77 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("na_if", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("near")
> ### * near
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: near
> ### Title: Compare two numeric vectors
> ### Aliases: near
> 
> ### ** Examples
> 
> sqrt(2) ^ 2 == 2
[1] FALSE
> near(sqrt(2) ^ 2, 2)
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("near", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("nest_by")
> ### * nest_by
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nest_by
> ### Title: Nest by one or more variables
> ### Aliases: nest_by
> ### Keywords: internal
> 
> ### ** Examples
> 
> # After nesting, you get one row per group
> iris %>% nest_by(Species)
# A tibble: 3 × 2
# Rowwise:  Species
  Species                  data
  <fct>      <list<tibble[,4]>>
1 setosa               [50 × 4]
2 versicolor           [50 × 4]
3 virginica            [50 × 4]
> starwars %>% nest_by(species)
# A tibble: 38 × 2
# Rowwise:  species
   species                  data
   <chr>     <list<tibble[,13]>>
 1 Aleena               [1 × 13]
 2 Besalisk             [1 × 13]
 3 Cerean               [1 × 13]
 4 Chagrian             [1 × 13]
 5 Clawdite             [1 × 13]
 6 Droid                [6 × 13]
 7 Dug                  [1 × 13]
 8 Ewok                 [1 × 13]
 9 Geonosian            [1 × 13]
10 Gungan               [3 × 13]
# ℹ 28 more rows
> 
> # The output is grouped by row, which makes modelling particularly easy
> models <- mtcars %>%
+   nest_by(cyl) %>%
+   mutate(model = list(lm(mpg ~ wt, data = data)))
> models
# A tibble: 3 × 3
# Rowwise:  cyl
    cyl                data model 
  <dbl> <list<tibble[,10]>> <list>
1     4           [11 × 10] <lm>  
2     6            [7 × 10] <lm>  
3     8           [14 × 10] <lm>  
> 
> models %>% summarise(rsq = summary(model)$r.squared)
`summarise()` has grouped output by 'cyl'. You can override using the `.groups`
argument.
# A tibble: 3 × 2
# Groups:   cyl [3]
    cyl   rsq
  <dbl> <dbl>
1     4 0.509
2     6 0.465
3     8 0.423
> ## Don't show: 
> if (requireNamespace("broom", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ 
+ # This is particularly elegant with the broom functions
+ models %>% summarise(broom::glance(model))
+ models %>% reframe(broom::tidy(model))
+ ## Don't show: 
+ }) # examplesIf
> models %>% summarise(broom::glance(model))
`summarise()` has grouped output by 'cyl'. You can override using the `.groups`
argument.
# A tibble: 3 × 13
# Groups:   cyl [3]
    cyl r.squared adj.r.squared sigma statistic p.value    df logLik   AIC   BIC
  <dbl>     <dbl>         <dbl> <dbl>     <dbl>   <dbl> <dbl>  <dbl> <dbl> <dbl>
1     4     0.509         0.454  3.33      9.32  0.0137     1 -27.7   61.5  62.7
2     6     0.465         0.357  1.17      4.34  0.0918     1  -9.83  25.7  25.5
3     8     0.423         0.375  2.02      8.80  0.0118     1 -28.7   63.3  65.2
# ℹ 3 more variables: deviance <dbl>, df.residual <int>, nobs <int>
> models %>% reframe(broom::tidy(model))
# A tibble: 6 × 6
    cyl term        estimate std.error statistic    p.value
  <dbl> <chr>          <dbl>     <dbl>     <dbl>      <dbl>
1     4 (Intercept)    39.6      4.35       9.10 0.00000777
2     4 wt             -5.65     1.85      -3.05 0.0137    
3     6 (Intercept)    28.4      4.18       6.79 0.00105   
4     6 wt             -2.78     1.33      -2.08 0.0918    
5     8 (Intercept)    23.9      3.01       7.94 0.00000405
6     8 wt             -2.19     0.739     -2.97 0.0118    
> ## End(Don't show)
> 
> # Note that you can also `reframe()` to unnest the data
> models %>% reframe(data)
# A tibble: 32 × 11
     cyl   mpg  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1     4  22.8 108      93  3.85  2.32  18.6     1     1     4     1
 2     4  24.4 147.     62  3.69  3.19  20       1     0     4     2
 3     4  22.8 141.     95  3.92  3.15  22.9     1     0     4     2
 4     4  32.4  78.7    66  4.08  2.2   19.5     1     1     4     1
 5     4  30.4  75.7    52  4.93  1.62  18.5     1     1     4     2
 6     4  33.9  71.1    65  4.22  1.84  19.9     1     1     4     1
 7     4  21.5 120.     97  3.7   2.46  20.0     1     0     3     1
 8     4  27.3  79      66  4.08  1.94  18.9     1     1     4     1
 9     4  26   120.     91  4.43  2.14  16.7     0     1     5     2
10     4  30.4  95.1   113  3.77  1.51  16.9     1     1     5     2
# ℹ 22 more rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nest_by", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("nest_join")
> ### * nest_join
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nest_join
> ### Title: Nest join
> ### Aliases: nest_join nest_join.data.frame
> 
> ### ** Examples
> 
> df1 <- tibble(x = 1:3)
> df2 <- tibble(x = c(2, 3, 3), y = c("a", "b", "c"))
> 
> out <- nest_join(df1, df2)
Joining with `by = join_by(x)`
> out
# A tibble: 3 × 2
      x df2             
  <dbl> <list>          
1     1 <tibble [0 × 1]>
2     2 <tibble [1 × 1]>
3     3 <tibble [2 × 1]>
> out$df2
[[1]]
# A tibble: 0 × 1
# ℹ 1 variable: y <chr>

[[2]]
# A tibble: 1 × 1
  y    
  <chr>
1 a    

[[3]]
# A tibble: 2 × 1
  y    
  <chr>
1 b    
2 c    

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nest_join", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("new_grouped_df")
> ### * new_grouped_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: new_grouped_df
> ### Title: Low-level construction and validation for the grouped_df and
> ###   rowwise_df classes
> ### Aliases: new_grouped_df validate_grouped_df new_rowwise_df
> ###   validate_rowwise_df
> ### Keywords: internal
> 
> ### ** Examples
> 
> # 5 bootstrap samples
> tbl <- new_grouped_df(
+   tibble(x = rnorm(10)),
+   groups = tibble(".rows" := replicate(5, sample(1:10, replace = TRUE), simplify = FALSE))
+ )
> # mean of each bootstrap sample
> summarise(tbl, x = mean(x))
# A tibble: 5 × 1
        x
    <dbl>
1  0.350 
2  0.0767
3  0.223 
4 -0.264 
5  0.0108
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("new_grouped_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("nth")
> ### * nth
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: nth
> ### Title: Extract the first, last, or nth value from a vector
> ### Aliases: nth first last
> 
> ### ** Examples
> 
> x <- 1:10
> y <- 10:1
> 
> first(x)
[1] 1
> last(y)
[1] 1
> 
> nth(x, 1)
[1] 1
> nth(x, 5)
[1] 5
> nth(x, -2)
[1] 9
> 
> # `first()` and `last()` are often useful in `summarise()`
> df <- tibble(x = x, y = y)
> df %>%
+   summarise(
+     across(x:y, first, .names = "{col}_first"),
+     y_last = last(y)
+   )
# A tibble: 1 × 3
  x_first y_first y_last
    <int>   <int>  <int>
1       1      10      1
> 
> # Selecting a position that is out of bounds returns a default value
> nth(x, 11)
[1] NA
> nth(x, 0)
[1] NA
> 
> # This out of bounds behavior also applies to empty vectors
> first(integer())
[1] NA
> 
> # You can customize the default value with `default`
> nth(x, 11, default = -1L)
[1] -1
> first(integer(), default = 0L)
[1] 0
> 
> # `order_by` provides optional ordering
> last(x)
[1] 10
> last(x, order_by = y)
[1] 1
> 
> # `na_rm` removes missing values before extracting the value
> z <- c(NA, NA, 1, 3, NA, 5, NA)
> first(z)
[1] NA
> first(z, na_rm = TRUE)
[1] 1
> last(z, na_rm = TRUE)
[1] 5
> nth(z, 3, na_rm = TRUE)
[1] 5
> 
> # For data frames, these select entire rows
> df <- tibble(a = 1:5, b = 6:10)
> first(df)
# A tibble: 1 × 2
      a     b
  <int> <int>
1     1     6
> nth(df, 4)
# A tibble: 1 × 2
      a     b
  <int> <int>
1     4     9
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("nth", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ntile")
> ### * ntile
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ntile
> ### Title: Bucket a numeric vector into 'n' groups
> ### Aliases: ntile
> 
> ### ** Examples
> 
> x <- c(5, 1, 3, 2, 2, NA)
> ntile(x, 2)
[1]  2  1  2  1  1 NA
> ntile(x, 4)
[1]  4  1  3  1  2 NA
> 
> # If the bucket sizes are uneven, the larger buckets come first
> ntile(1:8, 3)
[1] 1 1 1 2 2 2 3 3
> 
> # Ties are ignored
> ntile(rep(1, 8), 3)
[1] 1 1 1 2 2 2 3 3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ntile", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("order_by")
> ### * order_by
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: order_by
> ### Title: A helper function for ordering window function output
> ### Aliases: order_by
> 
> ### ** Examples
> 
> order_by(10:1, cumsum(1:10))
 [1] 55 54 52 49 45 40 34 27 19 10
> x <- 10:1
> y <- 1:10
> order_by(x, cumsum(y))
 [1] 55 54 52 49 45 40 34 27 19 10
> 
> df <- data.frame(year = 2000:2005, value = (0:5) ^ 2)
> scrambled <- df[sample(nrow(df)), ]
> 
> wrong <- mutate(scrambled, running = cumsum(value))
> arrange(wrong, year)
  year value running
1 2000     0       0
2 2001     1      39
3 2002     4      13
4 2003     9       9
5 2004    16      55
6 2005    25      38
> 
> right <- mutate(scrambled, running = order_by(year, cumsum(value)))
> arrange(right, year)
  year value running
1 2000     0       0
2 2001     1       1
3 2002     4       5
4 2003     9      14
5 2004    16      30
6 2005    25      55
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("order_by", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("percent_rank")
> ### * percent_rank
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: percent_rank
> ### Title: Proportional ranking functions
> ### Aliases: percent_rank cume_dist
> 
> ### ** Examples
> 
> x <- c(5, 1, 3, 2, 2)
> 
> cume_dist(x)
[1] 1.0 0.2 0.8 0.6 0.6
> percent_rank(x)
[1] 1.00 0.00 0.75 0.25 0.25
> 
> # You can understand what's going on by computing it by hand
> sapply(x, function(xi) sum(x <= xi) / length(x))
[1] 1.0 0.2 0.8 0.6 0.6
> sapply(x, function(xi) sum(x < xi)  / (length(x) - 1))
[1] 1.00 0.00 0.75 0.25 0.25
> # The real computations are a little more complex in order to
> # correctly deal with missing values
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("percent_rank", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pick")
> ### * pick
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pick
> ### Title: Select a subset of columns
> ### Aliases: pick
> 
> ### ** Examples
> 
> df <- tibble(
+   x = c(3, 2, 2, 2, 1),
+   y = c(0, 2, 1, 1, 4),
+   z1 = c("a", "a", "a", "b", "a"),
+   z2 = c("c", "d", "d", "a", "c")
+ )
> df
# A tibble: 5 × 4
      x     y z1    z2   
  <dbl> <dbl> <chr> <chr>
1     3     0 a     c    
2     2     2 a     d    
3     2     1 a     d    
4     2     1 b     a    
5     1     4 a     c    
> 
> # `pick()` provides a way to select a subset of your columns using
> # tidyselect. It returns a data frame.
> df %>% mutate(cols = pick(x, y))
# A tibble: 5 × 5
      x     y z1    z2    cols$x    $y
  <dbl> <dbl> <chr> <chr>  <dbl> <dbl>
1     3     0 a     c          3     0
2     2     2 a     d          2     2
3     2     1 a     d          2     1
4     2     1 b     a          2     1
5     1     4 a     c          1     4
> 
> # This is useful for functions that take data frames as inputs.
> # For example, you can compute a joint rank between `x` and `y`.
> df %>% mutate(rank = dense_rank(pick(x, y)))
# A tibble: 5 × 5
      x     y z1    z2     rank
  <dbl> <dbl> <chr> <chr> <int>
1     3     0 a     c         4
2     2     2 a     d         3
3     2     1 a     d         2
4     2     1 b     a         2
5     1     4 a     c         1
> 
> # `pick()` is also useful as a bridge between data-masking functions (like
> # `mutate()` or `group_by()`) and functions with tidy-select behavior (like
> # `select()`). For example, you can use `pick()` to create a wrapper around
> # `group_by()` that takes a tidy-selection of columns to group on. For more
> # bridge patterns, see
> # https://rlang.r-lib.org/reference/topic-data-mask-programming.html#bridge-patterns.
> my_group_by <- function(data, cols) {
+   group_by(data, pick({{ cols }}))
+ }
> 
> df %>% my_group_by(c(x, starts_with("z")))
# A tibble: 5 × 4
# Groups:   x, z1, z2 [4]
      x     y z1    z2   
  <dbl> <dbl> <chr> <chr>
1     3     0 a     c    
2     2     2 a     d    
3     2     1 a     d    
4     2     1 b     a    
5     1     4 a     c    
> 
> # Or you can use it to dynamically select columns to `count()` by
> df %>% count(pick(starts_with("z")))
# A tibble: 3 × 3
  z1    z2        n
  <chr> <chr> <int>
1 a     c         2
2 a     d         2
3 b     a         1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pick", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("progress_estimated")
> ### * progress_estimated
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: progress_estimated
> ### Title: Progress bar with estimated time.
> ### Aliases: progress_estimated
> ### Keywords: internal
> 
> ### ** Examples
> 
> p <- progress_estimated(3)
Warning: `progress_estimated()` was deprecated in dplyr 1.0.0.
> p$tick()
> p$tick()
> p$tick()
> 
> p <- progress_estimated(3)
> for (i in 1:3) p$pause(0.1)$tick()$print()
> 
> p <- progress_estimated(3)
> p$tick()$print()$
+  pause(1)$stop()
> 
> # If min_time is set, progress bar not shown until that many
> # seconds have elapsed
> p <- progress_estimated(3, min_time = 3)
> for (i in 1:3) p$pause(0.1)$tick()$print()
> 
> ## Not run: 
> ##D p <- progress_estimated(10, min_time = 3)
> ##D for (i in 1:10) p$pause(0.5)$tick()$print()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("progress_estimated", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pull")
> ### * pull
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pull
> ### Title: Extract a single column
> ### Aliases: pull
> 
> ### ** Examples
> 
> mtcars %>% pull(-1)
 [1] 4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2
> mtcars %>% pull(1)
 [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
[31] 15.0 21.4
> mtcars %>% pull(cyl)
 [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4
> ## Don't show: 
> if (requireNamespace("dbplyr", quietly = TRUE) && requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ 
+ # Also works for remote sources
+ df <- dbplyr::memdb_frame(x = 1:10, y = 10:1, .name = "pull-ex")
+ df %>%
+   mutate(z = x * y) %>%
+   pull()
+ ## Don't show: 
+ }) # examplesIf
> df <- dbplyr::memdb_frame(x = 1:10, y = 10:1, .name = "pull-ex")
> df %>% mutate(z = x * y) %>% pull()
 [1] 10 18 24 28 30 30 28 24 18 10
> ## End(Don't show)
> 
> # Pull a named vector
> starwars %>% pull(height, name)
       Luke Skywalker                 C-3PO                 R2-D2 
                  172                   167                    96 
          Darth Vader           Leia Organa             Owen Lars 
                  202                   150                   178 
   Beru Whitesun Lars                 R5-D4     Biggs Darklighter 
                  165                    97                   183 
       Obi-Wan Kenobi      Anakin Skywalker        Wilhuff Tarkin 
                  182                   188                   180 
            Chewbacca              Han Solo                Greedo 
                  228                   180                   173 
Jabba Desilijic Tiure        Wedge Antilles      Jek Tono Porkins 
                  175                   170                   180 
                 Yoda             Palpatine             Boba Fett 
                   66                   170                   183 
                IG-88                 Bossk      Lando Calrissian 
                  200                   190                   177 
                Lobot                Ackbar            Mon Mothma 
                  175                   180                   150 
         Arvel Crynyd Wicket Systri Warrick             Nien Nunb 
                   NA                    88                   160 
         Qui-Gon Jinn           Nute Gunray         Finis Valorum 
                  193                   191                   170 
        Padmé Amidala         Jar Jar Binks          Roos Tarpals 
                  185                   196                   224 
           Rugor Nass              Ric Olié                 Watto 
                  206                   183                   137 
              Sebulba         Quarsh Panaka        Shmi Skywalker 
                  112                   183                   163 
           Darth Maul           Bib Fortuna           Ayla Secura 
                  175                   180                   178 
         Ratts Tyerel              Dud Bolt               Gasgano 
                   79                    94                   122 
       Ben Quadinaros            Mace Windu          Ki-Adi-Mundi 
                  163                   188                   198 
            Kit Fisto             Eeth Koth            Adi Gallia 
                  196                   171                   184 
          Saesee Tiin           Yarael Poof              Plo Koon 
                  188                   264                   188 
           Mas Amedda          Gregar Typho                 Cordé 
                  196                   185                   157 
          Cliegg Lars     Poggle the Lesser       Luminara Unduli 
                  183                   183                   170 
        Barriss Offee                 Dormé                 Dooku 
                  166                   165                   193 
  Bail Prestor Organa            Jango Fett            Zam Wesell 
                  191                   183                   168 
      Dexter Jettster               Lama Su               Taun We 
                  198                   229                   213 
           Jocasta Nu                R4-P17            Wat Tambor 
                  167                    96                   193 
             San Hill              Shaak Ti              Grievous 
                  191                   178                   216 
              Tarfful       Raymus Antilles             Sly Moore 
                  234                   188                   178 
           Tion Medon                  Finn                   Rey 
                  206                    NA                    NA 
          Poe Dameron                   BB8        Captain Phasma 
                   NA                    NA                    NA 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pull", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'dbplyr_cache'

> nameEx("recode")
> ### * recode
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: recode
> ### Title: Recode values
> ### Aliases: recode recode_factor
> 
> ### ** Examples
> 
> char_vec <- sample(c("a", "b", "c"), 10, replace = TRUE)
> 
> # `recode()` is superseded by `case_match()`
> recode(char_vec, a = "Apple", b = "Banana")
 [1] "Apple"  "c"      "Apple"  "Banana" "Apple"  "c"      "c"      "Banana"
 [9] "Banana" "c"     
> case_match(char_vec, "a" ~ "Apple", "b" ~ "Banana", .default = char_vec)
 [1] "Apple"  "c"      "Apple"  "Banana" "Apple"  "c"      "c"      "Banana"
 [9] "Banana" "c"     
> 
> # With `case_match()`, you don't need typed missings like `NA_character_`
> recode(char_vec, a = "Apple", b = "Banana", .default = NA_character_)
 [1] "Apple"  NA       "Apple"  "Banana" "Apple"  NA       NA       "Banana"
 [9] "Banana" NA      
> case_match(char_vec, "a" ~ "Apple", "b" ~ "Banana", .default = NA)
 [1] "Apple"  NA       "Apple"  "Banana" "Apple"  NA       NA       "Banana"
 [9] "Banana" NA      
> 
> # Throws an error as `NA` is logical, not character.
> try(recode(char_vec, a = "Apple", b = "Banana", .default = NA))
Error in recode(char_vec, a = "Apple", b = "Banana", .default = NA) : 
  `.default` must be a character vector, not `NA`.
> 
> # `case_match()` is easier to use with numeric vectors, because you don't
> # need to turn the numeric values into names
> num_vec <- c(1:4, NA)
> recode(num_vec, `2` = 20L, `4` = 40L)
[1]  1 20  3 40 NA
> case_match(num_vec, 2 ~ 20, 4 ~ 40, .default = num_vec)
[1]  1 20  3 40 NA
> 
> # `case_match()` doesn't have the ability to match by position like
> # `recode()` does with numeric vectors
> recode(num_vec, "a", "b", "c", "d")
[1] "a" "b" "c" "d" NA 
> recode(c(1,5,3), "a", "b", "c", "d", .default = "nothing")
[1] "a"       "nothing" "c"      
> 
> # For `case_match()`, incompatible types are an error rather than a warning
> recode(num_vec, `2` = "b", `4` = "d")
Warning: Unreplaced values treated as NA as `.x` is not compatible.
Please specify replacements exhaustively or supply `.default`.
[1] NA  "b" NA  "d" NA 
> try(case_match(num_vec, 2 ~ "b", 4 ~ "d", .default = num_vec))
Error in case_match(num_vec, 2 ~ "b", 4 ~ "d", .default = num_vec) : 
  Can't combine `..1 (right)` <character> and `.default` <integer>.
> 
> # The factor method of `recode()` can generally be replaced with
> # `forcats::fct_recode()`
> factor_vec <- factor(c("a", "b", "c"))
> recode(factor_vec, a = "Apple")
[1] Apple b     c    
Levels: Apple b c
> 
> # `recode_factor()` does not currently have a direct replacement, but we
> # plan to add one to forcats. In the meantime, you can use the `.ptype`
> # argument to `case_match()`.
> recode_factor(
+   num_vec,
+   `1` = "z",
+   `2` = "y",
+   `3` = "x",
+   .default = "D",
+   .missing = "M"
+ )
[1] z y x D M
Levels: z y x D M
> case_match(
+   num_vec,
+   1 ~ "z",
+   2 ~ "y",
+   3 ~ "x",
+   NA ~ "M",
+   .default = "D",
+   .ptype = factor(levels = c("z", "y", "x", "D", "M"))
+ )
[1] z y x D M
Levels: z y x D M
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("recode", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("reframe")
> ### * reframe
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: reframe
> ### Title: Transform each group to an arbitrary number of rows
> ### Aliases: reframe
> 
> ### ** Examples
> 
> table <- c("a", "b", "d", "f")
> 
> df <- tibble(
+   g = c(1, 1, 1, 2, 2, 2, 2),
+   x = c("e", "a", "b", "c", "f", "d", "a")
+ )
> 
> # `reframe()` allows you to apply functions that return
> # an arbitrary number of rows
> df %>%
+   reframe(x = intersect(x, table))
# A tibble: 4 × 1
  x    
  <chr>
1 a    
2 b    
3 f    
4 d    
> 
> # Functions are applied per group, and each group can return a
> # different number of rows.
> df %>%
+   reframe(x = intersect(x, table), .by = g)
# A tibble: 5 × 2
      g x    
  <dbl> <chr>
1     1 a    
2     1 b    
3     2 f    
4     2 d    
5     2 a    
> 
> # The output is always ungrouped, even when using `group_by()`
> df %>%
+   group_by(g) %>%
+   reframe(x = intersect(x, table))
# A tibble: 5 × 2
      g x    
  <dbl> <chr>
1     1 a    
2     1 b    
3     2 f    
4     2 d    
5     2 a    
> 
> # You can add multiple columns at once using a single expression by returning
> # a data frame.
> quantile_df <- function(x, probs = c(0.25, 0.5, 0.75)) {
+   tibble(
+     val = quantile(x, probs, na.rm = TRUE),
+     quant = probs
+   )
+ }
> 
> x <- c(10, 15, 18, 12)
> quantile_df(x)
# A tibble: 3 × 2
    val quant
  <dbl> <dbl>
1  11.5  0.25
2  13.5  0.5 
3  15.8  0.75
> 
> starwars %>%
+   reframe(quantile_df(height))
# A tibble: 3 × 2
    val quant
  <dbl> <dbl>
1   167  0.25
2   180  0.5 
3   191  0.75
> 
> starwars %>%
+   reframe(quantile_df(height), .by = homeworld)
# A tibble: 147 × 3
   homeworld   val quant
   <chr>     <dbl> <dbl>
 1 Tatooine   166.  0.25
 2 Tatooine   175   0.5 
 3 Tatooine   183   0.75
 4 Naboo      168.  0.25
 5 Naboo      183   0.5 
 6 Naboo      190.  0.75
 7 Alderaan   169   0.25
 8 Alderaan   188   0.5 
 9 Alderaan   190.  0.75
10 Stewjon    182   0.25
# ℹ 137 more rows
> 
> starwars %>%
+   reframe(
+     across(c(height, mass), quantile_df, .unpack = TRUE),
+     .by = homeworld
+   )
# A tibble: 147 × 5
   homeworld height_val height_quant mass_val mass_quant
   <chr>          <dbl>        <dbl>    <dbl>      <dbl>
 1 Tatooine        166.         0.25     75         0.25
 2 Tatooine        175          0.5      80.5       0.5 
 3 Tatooine        183          0.75     93         0.75
 4 Naboo           168.         0.25     50.2       0.25
 5 Naboo           183          0.5      70.5       0.5 
 6 Naboo           190.         0.75     80.2       0.75
 7 Alderaan        169          0.25     56.5       0.25
 8 Alderaan        188          0.5      64         0.5 
 9 Alderaan        190.         0.75     71.5       0.75
10 Stewjon         182          0.25     77         0.25
# ℹ 137 more rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("reframe", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("relocate")
> ### * relocate
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: relocate
> ### Title: Change column order
> ### Aliases: relocate
> 
> ### ** Examples
> 
> df <- tibble(a = 1, b = 1, c = 1, d = "a", e = "a", f = "a")
> df %>% relocate(f)
# A tibble: 1 × 6
  f         a     b     c d     e    
  <chr> <dbl> <dbl> <dbl> <chr> <chr>
1 a         1     1     1 a     a    
> df %>% relocate(a, .after = c)
# A tibble: 1 × 6
      b     c     a d     e     f    
  <dbl> <dbl> <dbl> <chr> <chr> <chr>
1     1     1     1 a     a     a    
> df %>% relocate(f, .before = b)
# A tibble: 1 × 6
      a f         b     c d     e    
  <dbl> <chr> <dbl> <dbl> <chr> <chr>
1     1 a         1     1 a     a    
> df %>% relocate(a, .after = last_col())
# A tibble: 1 × 6
      b     c d     e     f         a
  <dbl> <dbl> <chr> <chr> <chr> <dbl>
1     1     1 a     a     a         1
> 
> # relocated columns can change name
> df %>% relocate(ff = f)
# A tibble: 1 × 6
  ff        a     b     c d     e    
  <chr> <dbl> <dbl> <dbl> <chr> <chr>
1 a         1     1     1 a     a    
> 
> # Can also select variables based on their type
> df %>% relocate(where(is.character))
# A tibble: 1 × 6
  d     e     f         a     b     c
  <chr> <chr> <chr> <dbl> <dbl> <dbl>
1 a     a     a         1     1     1
> df %>% relocate(where(is.numeric), .after = last_col())
# A tibble: 1 × 6
  d     e     f         a     b     c
  <chr> <chr> <chr> <dbl> <dbl> <dbl>
1 a     a     a         1     1     1
> # Or with any other select helper
> df %>% relocate(any_of(c("a", "e", "i", "o", "u")))
# A tibble: 1 × 6
      a e         b     c d     f    
  <dbl> <chr> <dbl> <dbl> <chr> <chr>
1     1 a         1     1 a     a    
> 
> # When .before or .after refers to multiple variables they will be
> # moved to be immediately before/after the selected variables.
> df2 <- tibble(a = 1, b = "a", c = 1, d = "a")
> df2 %>% relocate(where(is.numeric), .after = where(is.character))
# A tibble: 1 × 4
  b     d         a     c
  <chr> <chr> <dbl> <dbl>
1 a     a         1     1
> df2 %>% relocate(where(is.numeric), .before = where(is.character))
# A tibble: 1 × 4
      a     c b     d    
  <dbl> <dbl> <chr> <chr>
1     1     1 a     a    
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("relocate", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rename")
> ### * rename
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rename
> ### Title: Rename columns
> ### Aliases: rename rename_with
> 
> ### ** Examples
> 
> iris <- as_tibble(iris) # so it prints a little nicer
> rename(iris, petal_length = Petal.Length)
# A tibble: 150 × 5
   Sepal.Length Sepal.Width petal_length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> 
> # Rename using a named vector and `all_of()`
> lookup <- c(pl = "Petal.Length", sl = "Sepal.Length")
> rename(iris, all_of(lookup))
# A tibble: 150 × 5
      sl Sepal.Width    pl Petal.Width Species
   <dbl>       <dbl> <dbl>       <dbl> <fct>  
 1   5.1         3.5   1.4         0.2 setosa 
 2   4.9         3     1.4         0.2 setosa 
 3   4.7         3.2   1.3         0.2 setosa 
 4   4.6         3.1   1.5         0.2 setosa 
 5   5           3.6   1.4         0.2 setosa 
 6   5.4         3.9   1.7         0.4 setosa 
 7   4.6         3.4   1.4         0.3 setosa 
 8   5           3.4   1.5         0.2 setosa 
 9   4.4         2.9   1.4         0.2 setosa 
10   4.9         3.1   1.5         0.1 setosa 
# ℹ 140 more rows
> 
> # If your named vector might contain names that don't exist in the data,
> # use `any_of()` instead
> lookup <- c(lookup, new = "unknown")
> try(rename(iris, all_of(lookup)))
Error in rename(iris, all_of(lookup)) : ℹ In argument: `all_of(lookup)`.
Caused by error in `all_of()`:
! Can't subset elements that don't exist.
✖ Element `unknown` doesn't exist.
> rename(iris, any_of(lookup))
# A tibble: 150 × 5
      sl Sepal.Width    pl Petal.Width Species
   <dbl>       <dbl> <dbl>       <dbl> <fct>  
 1   5.1         3.5   1.4         0.2 setosa 
 2   4.9         3     1.4         0.2 setosa 
 3   4.7         3.2   1.3         0.2 setosa 
 4   4.6         3.1   1.5         0.2 setosa 
 5   5           3.6   1.4         0.2 setosa 
 6   5.4         3.9   1.7         0.4 setosa 
 7   4.6         3.4   1.4         0.3 setosa 
 8   5           3.4   1.5         0.2 setosa 
 9   4.4         2.9   1.4         0.2 setosa 
10   4.9         3.1   1.5         0.1 setosa 
# ℹ 140 more rows
> 
> rename_with(iris, toupper)
# A tibble: 150 × 5
   SEPAL.LENGTH SEPAL.WIDTH PETAL.LENGTH PETAL.WIDTH SPECIES
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> rename_with(iris, toupper, starts_with("Petal"))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width PETAL.LENGTH PETAL.WIDTH Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> rename_with(iris, ~ tolower(gsub(".", "_", .x, fixed = TRUE)))
# A tibble: 150 × 5
   sepal_length sepal_width petal_length petal_width species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> 
> ## Don't show: 
> if (getRversion() > "4.0.1") (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ # If your renaming function uses `paste0()`, make sure to set
+ # `recycle0 = TRUE` to ensure that empty selections are recycled correctly
+ try(rename_with(
+   iris,
+   ~ paste0("prefix_", .x),
+   starts_with("nonexistent")
+ ))
+ 
+ rename_with(
+   iris,
+   ~ paste0("prefix_", .x, recycle0 = TRUE),
+   starts_with("nonexistent")
+ )
+ ## Don't show: 
+ }) # examplesIf
> try(rename_with(iris, ~paste0("prefix_", .x), starts_with("nonexistent")))
Error in rename_with(iris, ~paste0("prefix_", .x), starts_with("nonexistent")) : 
  `.fn` must return a vector of length 0, not 1.
> rename_with(iris, ~paste0("prefix_", .x, recycle0 = TRUE), starts_with("nonexistent"))
# A tibble: 150 × 5
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
          <dbl>       <dbl>        <dbl>       <dbl> <fct>  
 1          5.1         3.5          1.4         0.2 setosa 
 2          4.9         3            1.4         0.2 setosa 
 3          4.7         3.2          1.3         0.2 setosa 
 4          4.6         3.1          1.5         0.2 setosa 
 5          5           3.6          1.4         0.2 setosa 
 6          5.4         3.9          1.7         0.4 setosa 
 7          4.6         3.4          1.4         0.3 setosa 
 8          5           3.4          1.5         0.2 setosa 
 9          4.4         2.9          1.4         0.2 setosa 
10          4.9         3.1          1.5         0.1 setosa 
# ℹ 140 more rows
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rename", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("row_number")
> ### * row_number
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: row_number
> ### Title: Integer ranking functions
> ### Aliases: row_number min_rank dense_rank
> 
> ### ** Examples
> 
> x <- c(5, 1, 3, 2, 2, NA)
> row_number(x)
[1]  5  1  4  2  3 NA
> min_rank(x)
[1]  5  1  4  2  2 NA
> dense_rank(x)
[1]  4  1  3  2  2 NA
> 
> # Ranking functions can be used in `filter()` to select top/bottom rows
> df <- data.frame(
+   grp = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
+   x = c(3, 2, 1, 1, 2, 2, 1, 1, 1),
+   y = c(1, 3, 2, 3, 2, 2, 4, 1, 2),
+   id = 1:9
+ )
> # Always gives exactly 1 row per group
> df %>% group_by(grp) %>% filter(row_number(x) == 1)
# A tibble: 3 × 4
# Groups:   grp [3]
    grp     x     y    id
  <dbl> <dbl> <dbl> <int>
1     1     1     2     3
2     2     1     3     4
3     3     1     4     7
> # May give more than 1 row if ties
> df %>% group_by(grp) %>% filter(min_rank(x) == 1)
# A tibble: 5 × 4
# Groups:   grp [3]
    grp     x     y    id
  <dbl> <dbl> <dbl> <int>
1     1     1     2     3
2     2     1     3     4
3     3     1     4     7
4     3     1     1     8
5     3     1     2     9
> # Rank by multiple columns (to break ties) by selecting them with `pick()`
> df %>% group_by(grp) %>% filter(min_rank(pick(x, y)) == 1)
# A tibble: 3 × 4
# Groups:   grp [3]
    grp     x     y    id
  <dbl> <dbl> <dbl> <int>
1     1     1     2     3
2     2     1     3     4
3     3     1     1     8
> # See slice_min() and slice_max() for another way to tackle the same problem
> 
> # You can use row_number() without an argument to refer to the "current"
> # row number.
> df %>% group_by(grp) %>% filter(row_number() == 1)
# A tibble: 3 × 4
# Groups:   grp [3]
    grp     x     y    id
  <dbl> <dbl> <dbl> <int>
1     1     3     1     1
2     2     1     3     4
3     3     1     4     7
> 
> # It's easiest to see what this does with mutate():
> df %>% group_by(grp) %>% mutate(grp_id = row_number())
# A tibble: 9 × 5
# Groups:   grp [3]
    grp     x     y    id grp_id
  <dbl> <dbl> <dbl> <int>  <int>
1     1     3     1     1      1
2     1     2     3     2      2
3     1     1     2     3      3
4     2     1     3     4      1
5     2     2     2     5      2
6     2     2     2     6      3
7     3     1     4     7      1
8     3     1     1     8      2
9     3     1     2     9      3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("row_number", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rows")
> ### * rows
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rows
> ### Title: Manipulate individual rows
> ### Aliases: rows rows_insert rows_append rows_update rows_patch
> ###   rows_upsert rows_delete
> 
> ### ** Examples
> 
> data <- tibble(a = 1:3, b = letters[c(1:2, NA)], c = 0.5 + 0:2)
> data
# A tibble: 3 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 b       1.5
3     3 <NA>    2.5
> 
> # Insert
> rows_insert(data, tibble(a = 4, b = "z"))
Matching, by = "a"
# A tibble: 4 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 b       1.5
3     3 <NA>    2.5
4     4 z      NA  
> 
> # By default, if a key in `y` matches a key in `x`, then it can't be inserted
> # and will throw an error. Alternatively, you can ignore rows in `y`
> # containing keys that conflict with keys in `x` with `conflict = "ignore"`,
> # or you can use `rows_append()` to ignore keys entirely.
> try(rows_insert(data, tibble(a = 3, b = "z")))
Matching, by = "a"
Error in rows_insert(data, tibble(a = 3, b = "z")) : 
  `y` can't contain keys that already exist in `x`.
ℹ The following rows in `y` have keys that already exist in `x`: `c(1)`.
ℹ Use `conflict = "ignore"` if you want to ignore these `y` rows.
> rows_insert(data, tibble(a = 3, b = "z"), conflict = "ignore")
Matching, by = "a"
# A tibble: 3 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 b       1.5
3     3 <NA>    2.5
> rows_append(data, tibble(a = 3, b = "z"))
# A tibble: 4 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 b       1.5
3     3 <NA>    2.5
4     3 z      NA  
> 
> # Update
> rows_update(data, tibble(a = 2:3, b = "z"))
Matching, by = "a"
# A tibble: 3 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 z       1.5
3     3 z       2.5
> rows_update(data, tibble(b = "z", a = 2:3), by = "a")
# A tibble: 3 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 z       1.5
3     3 z       2.5
> 
> # Variants: patch and upsert
> rows_patch(data, tibble(a = 2:3, b = "z"))
Matching, by = "a"
# A tibble: 3 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 b       1.5
3     3 z       2.5
> rows_upsert(data, tibble(a = 2:4, b = "z"))
Matching, by = "a"
# A tibble: 4 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 z       1.5
3     3 z       2.5
4     4 z      NA  
> 
> # Delete and truncate
> rows_delete(data, tibble(a = 2:3))
Matching, by = "a"
# A tibble: 1 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
> rows_delete(data, tibble(a = 2:3, b = "b"))
Matching, by = "a"
Ignoring extra `y` columns: b
# A tibble: 1 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
> 
> # By default, for update, patch, and delete it is an error if a key in `y`
> # doesn't exist in `x`. You can ignore rows in `y` that have unmatched keys
> # with `unmatched = "ignore"`.
> y <- tibble(a = 3:4, b = "z")
> try(rows_update(data, y, by = "a"))
Error in rows_update(data, y, by = "a") : 
  `y` must contain keys that already exist in `x`.
ℹ The following rows in `y` have keys that don't exist in `x`: `c(2)`.
ℹ Use `unmatched = "ignore"` if you want to ignore these `y` rows.
> rows_update(data, y, by = "a", unmatched = "ignore")
# A tibble: 3 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 b       1.5
3     3 z       2.5
> rows_patch(data, y, by = "a", unmatched = "ignore")
# A tibble: 3 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 b       1.5
3     3 z       2.5
> rows_delete(data, y, by = "a", unmatched = "ignore")
Ignoring extra `y` columns: b
# A tibble: 2 × 3
      a b         c
  <int> <chr> <dbl>
1     1 a       0.5
2     2 b       1.5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rows", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rowwise")
> ### * rowwise
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rowwise
> ### Title: Group input by rows
> ### Aliases: rowwise
> 
> ### ** Examples
> 
> df <- tibble(x = runif(6), y = runif(6), z = runif(6))
> # Compute the mean of x, y, z in each row
> df %>% rowwise() %>% mutate(m = mean(c(x, y, z)))
# A tibble: 6 × 4
# Rowwise: 
      x      y     z     m
  <dbl>  <dbl> <dbl> <dbl>
1 0.266 0.945  0.687 0.632
2 0.372 0.661  0.384 0.472
3 0.573 0.629  0.770 0.657
4 0.908 0.0618 0.498 0.489
5 0.202 0.206  0.718 0.375
6 0.898 0.177  0.992 0.689
> # use c_across() to more easily select many variables
> df %>% rowwise() %>% mutate(m = mean(c_across(x:z)))
# A tibble: 6 × 4
# Rowwise: 
      x      y     z     m
  <dbl>  <dbl> <dbl> <dbl>
1 0.266 0.945  0.687 0.632
2 0.372 0.661  0.384 0.472
3 0.573 0.629  0.770 0.657
4 0.908 0.0618 0.498 0.489
5 0.202 0.206  0.718 0.375
6 0.898 0.177  0.992 0.689
> 
> # Compute the minimum of x and y in each row
> df %>% rowwise() %>% mutate(m = min(c(x, y, z)))
# A tibble: 6 × 4
# Rowwise: 
      x      y     z      m
  <dbl>  <dbl> <dbl>  <dbl>
1 0.266 0.945  0.687 0.266 
2 0.372 0.661  0.384 0.372 
3 0.573 0.629  0.770 0.573 
4 0.908 0.0618 0.498 0.0618
5 0.202 0.206  0.718 0.202 
6 0.898 0.177  0.992 0.177 
> # In this case you can use an existing vectorised function:
> df %>% mutate(m = pmin(x, y, z))
# A tibble: 6 × 4
      x      y     z      m
  <dbl>  <dbl> <dbl>  <dbl>
1 0.266 0.945  0.687 0.266 
2 0.372 0.661  0.384 0.372 
3 0.573 0.629  0.770 0.573 
4 0.908 0.0618 0.498 0.0618
5 0.202 0.206  0.718 0.202 
6 0.898 0.177  0.992 0.177 
> # Where these functions exist they'll be much faster than rowwise
> # so be on the lookout for them.
> 
> # rowwise() is also useful when doing simulations
> params <- tribble(
+  ~sim, ~n, ~mean, ~sd,
+     1,  1,     1,   1,
+     2,  2,     2,   4,
+     3,  3,    -1,   2
+ )
> # Here I supply variables to preserve after the computation
> params %>%
+   rowwise(sim) %>%
+   reframe(z = rnorm(n, mean, sd))
# A tibble: 6 × 2
    sim      z
  <dbl>  <dbl>
1     1  0.695
2     2  8.05 
3     2  3.56 
4     3 -2.24 
5     3 -5.43 
6     3  1.25 
> 
> # If you want one row per simulation, put the results in a list()
> params %>%
+   rowwise(sim) %>%
+   summarise(z = list(rnorm(n, mean, sd)), .groups = "keep")
# A tibble: 3 × 2
# Groups:   sim [3]
    sim z        
  <dbl> <list>   
1     1 <dbl [1]>
2     2 <dbl [2]>
3     3 <dbl [3]>
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rowwise", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sample_n")
> ### * sample_n
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sample_n
> ### Title: Sample n rows from a table
> ### Aliases: sample_n sample_frac
> ### Keywords: internal
> 
> ### ** Examples
> 
> df <- tibble(x = 1:5, w = c(0.1, 0.1, 0.1, 2, 2))
> 
> # sample_n() -> slice_sample() ----------------------------------------------
> # Was:
> sample_n(df, 3)
# A tibble: 3 × 2
      x     w
  <int> <dbl>
1     1   0.1
2     4   2  
3     3   0.1
> sample_n(df, 10, replace = TRUE)
# A tibble: 10 × 2
       x     w
   <int> <dbl>
 1     1   0.1
 2     2   0.1
 3     5   2  
 4     3   0.1
 5     2   0.1
 6     3   0.1
 7     3   0.1
 8     1   0.1
 9     5   2  
10     5   2  
> sample_n(df, 3, weight = w)
# A tibble: 3 × 2
      x     w
  <int> <dbl>
1     4   2  
2     5   2  
3     1   0.1
> 
> # Now:
> slice_sample(df, n = 3)
# A tibble: 3 × 2
      x     w
  <int> <dbl>
1     2   0.1
2     3   0.1
3     1   0.1
> slice_sample(df, n = 10, replace = TRUE)
# A tibble: 10 × 2
       x     w
   <int> <dbl>
 1     5   2  
 2     5   2  
 3     1   0.1
 4     1   0.1
 5     5   2  
 6     5   2  
 7     2   0.1
 8     2   0.1
 9     1   0.1
10     4   2  
> slice_sample(df, n = 3, weight_by = w)
# A tibble: 3 × 2
      x     w
  <int> <dbl>
1     4   2  
2     5   2  
3     1   0.1
> 
> # Note that sample_n() would error if n was bigger than the group size
> # slice_sample() will just use the available rows for consistency with
> # the other slice helpers like slice_head()
> try(sample_n(df, 10))
Error in sample_n(df, 10) : Can't compute indices.
Caused by error:
! `size` must be less than or equal to 5 (size of data).
ℹ set `replace = TRUE` to use sampling with replacement.
> slice_sample(df, n = 10)
# A tibble: 5 × 2
      x     w
  <int> <dbl>
1     3   0.1
2     2   0.1
3     4   2  
4     5   2  
5     1   0.1
> 
> # sample_frac() -> slice_sample() -------------------------------------------
> # Was:
> sample_frac(df, 0.25)
# A tibble: 1 × 2
      x     w
  <int> <dbl>
1     4     2
> sample_frac(df, 2, replace = TRUE)
# A tibble: 10 × 2
       x     w
   <int> <dbl>
 1     4   2  
 2     4   2  
 3     2   0.1
 4     4   2  
 5     1   0.1
 6     1   0.1
 7     4   2  
 8     1   0.1
 9     2   0.1
10     3   0.1
> 
> # Now:
> slice_sample(df, prop = 0.25)
# A tibble: 1 × 2
      x     w
  <int> <dbl>
1     2   0.1
> slice_sample(df, prop = 2, replace = TRUE)
# A tibble: 10 × 2
       x     w
   <int> <dbl>
 1     2   0.1
 2     5   2  
 3     2   0.1
 4     1   0.1
 5     3   0.1
 6     3   0.1
 7     4   2  
 8     3   0.1
 9     1   0.1
10     4   2  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sample_n", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("select_all")
> ### * select_all
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: select_all
> ### Title: Select and rename a selection of variables
> ### Aliases: select_all rename_all select_if rename_if select_at rename_at
> ### Keywords: internal
> 
> ### ** Examples
> 
> mtcars <- as_tibble(mtcars) # for nicer printing
> 
> mtcars %>% rename_all(toupper)
# A tibble: 32 × 11
     MPG   CYL  DISP    HP  DRAT    WT  QSEC    VS    AM  GEAR  CARB
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> # ->
> mtcars %>% rename_with(toupper)
# A tibble: 32 × 11
     MPG   CYL  DISP    HP  DRAT    WT  QSEC    VS    AM  GEAR  CARB
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> 
> # NB: the transformation comes first in rename_with
> is_whole <- function(x) all(floor(x) == x)
> mtcars %>% rename_if(is_whole, toupper)
# A tibble: 32 × 11
     mpg   CYL  disp    HP  drat    wt  qsec    VS    AM  GEAR  CARB
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> # ->
> mtcars %>% rename_with(toupper, where(is_whole))
# A tibble: 32 × 11
     mpg   CYL  disp    HP  drat    wt  qsec    VS    AM  GEAR  CARB
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> 
> mtcars %>% rename_at(vars(mpg:hp), toupper)
# A tibble: 32 × 11
     MPG   CYL  DISP    HP  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> # ->
> mtcars %>% rename_with(toupper, mpg:hp)
# A tibble: 32 × 11
     MPG   CYL  DISP    HP  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> 
> # You now must select() and then rename
> 
> mtcars %>% select_all(toupper)
# A tibble: 32 × 11
     MPG   CYL  DISP    HP  DRAT    WT  QSEC    VS    AM  GEAR  CARB
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> # ->
> mtcars %>% rename_with(toupper)
# A tibble: 32 × 11
     MPG   CYL  DISP    HP  DRAT    WT  QSEC    VS    AM  GEAR  CARB
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ 22 more rows
> 
> # Selection drops unselected variables:
> mtcars %>% select_if(is_whole, toupper)
# A tibble: 32 × 6
     CYL    HP    VS    AM  GEAR  CARB
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1     6   110     0     1     4     4
 2     6   110     0     1     4     4
 3     4    93     1     1     4     1
 4     6   110     1     0     3     1
 5     8   175     0     0     3     2
 6     6   105     1     0     3     1
 7     8   245     0     0     3     4
 8     4    62     1     0     4     2
 9     4    95     1     0     4     2
10     6   123     1     0     4     4
# ℹ 22 more rows
> # ->
> mtcars %>% select(where(is_whole)) %>% rename_with(toupper)
# A tibble: 32 × 6
     CYL    HP    VS    AM  GEAR  CARB
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1     6   110     0     1     4     4
 2     6   110     0     1     4     4
 3     4    93     1     1     4     1
 4     6   110     1     0     3     1
 5     8   175     0     0     3     2
 6     6   105     1     0     3     1
 7     8   245     0     0     3     4
 8     4    62     1     0     4     2
 9     4    95     1     0     4     2
10     6   123     1     0     4     4
# ℹ 22 more rows
> 
> mtcars %>% select_at(vars(-contains("ar"), starts_with("c")), toupper)
# A tibble: 32 × 10
     MPG   CYL  DISP    HP  DRAT    WT  QSEC    VS    AM  CARB
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4
# ℹ 22 more rows
> # ->
> mtcars %>%
+   select(!contains("ar") | starts_with("c")) %>%
+   rename_with(toupper)
# A tibble: 32 × 10
     MPG   CYL  DISP    HP  DRAT    WT  QSEC    VS    AM  CARB
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4
# ℹ 22 more rows
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("select_all", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("setops")
> ### * setops
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: setops
> ### Title: Set operations
> ### Aliases: setops intersect union union_all setdiff setequal symdiff
> 
> ### ** Examples
> 
> df1 <- tibble(x = 1:3)
> df2 <- tibble(x = 3:5)
> 
> intersect(df1, df2)
# A tibble: 1 × 1
      x
  <int>
1     3
> union(df1, df2)
# A tibble: 5 × 1
      x
  <int>
1     1
2     2
3     3
4     4
5     5
> union_all(df1, df2)
# A tibble: 6 × 1
      x
  <int>
1     1
2     2
3     3
4     3
5     4
6     5
> setdiff(df1, df2)
# A tibble: 2 × 1
      x
  <int>
1     1
2     2
> setdiff(df2, df1)
# A tibble: 2 × 1
      x
  <int>
1     4
2     5
> symdiff(df1, df2)
# A tibble: 4 × 1
      x
  <int>
1     1
2     2
3     4
4     5
> 
> setequal(df1, df2)
[1] FALSE
> setequal(df1, df1[3:1, ])
[1] TRUE
> 
> # Note that the following functions remove pre-existing duplicates:
> df1 <- tibble(x = c(1:3, 3, 3))
> df2 <- tibble(x = c(3:5, 5))
> 
> intersect(df1, df2)
# A tibble: 1 × 1
      x
  <dbl>
1     3
> union(df1, df2)
# A tibble: 5 × 1
      x
  <dbl>
1     1
2     2
3     3
4     4
5     5
> setdiff(df1, df2)
# A tibble: 2 × 1
      x
  <dbl>
1     1
2     2
> symdiff(df1, df2)
# A tibble: 4 × 1
      x
  <dbl>
1     1
2     2
3     4
4     5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("setops", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("slice")
> ### * slice
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: slice
> ### Title: Subset rows using their positions
> ### Aliases: slice slice_head slice_tail slice_min slice_max slice_sample
> 
> ### ** Examples
> 
> # Similar to head(mtcars, 1):
> mtcars %>% slice(1L)
          mpg cyl disp  hp drat   wt  qsec vs am gear carb
Mazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4
> # Similar to tail(mtcars, 1):
> mtcars %>% slice(n())
            mpg cyl disp  hp drat   wt qsec vs am gear carb
Volvo 142E 21.4   4  121 109 4.11 2.78 18.6  1  1    4    2
> mtcars %>% slice(5:n())
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> # Rows can be dropped with negative indices:
> slice(mtcars, -(1:4))
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> 
> # First and last rows based on existing order
> mtcars %>% slice_head(n = 5)
                   mpg cyl disp  hp drat    wt  qsec vs am gear carb
Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
> mtcars %>% slice_tail(n = 5)
                mpg cyl  disp  hp drat    wt qsec vs am gear carb
Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2
Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4
Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6
Maserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8
Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2
> 
> # Rows with minimum and maximum values of a variable
> mtcars %>% slice_min(mpg, n = 5)
                     mpg cyl disp  hp drat    wt  qsec vs am gear carb
Cadillac Fleetwood  10.4   8  472 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4
Camaro Z28          13.3   8  350 245 3.73 3.840 15.41  0  0    3    4
Duster 360          14.3   8  360 245 3.21 3.570 15.84  0  0    3    4
Chrysler Imperial   14.7   8  440 230 3.23 5.345 17.42  0  0    3    4
> mtcars %>% slice_max(mpg, n = 5)
                mpg cyl disp  hp drat    wt  qsec vs am gear carb
Toyota Corolla 33.9   4 71.1  65 4.22 1.835 19.90  1  1    4    1
Fiat 128       32.4   4 78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic    30.4   4 75.7  52 4.93 1.615 18.52  1  1    4    2
Lotus Europa   30.4   4 95.1 113 3.77 1.513 16.90  1  1    5    2
Fiat X1-9      27.3   4 79.0  66 4.08 1.935 18.90  1  1    4    1
> 
> # slice_min() and slice_max() may return more rows than requested
> # in the presence of ties.
> mtcars %>% slice_min(cyl, n = 1)
                mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> # Use with_ties = FALSE to return exactly n matches
> mtcars %>% slice_min(cyl, n = 1, with_ties = FALSE)
            mpg cyl disp hp drat   wt  qsec vs am gear carb
Datsun 710 22.8   4  108 93 3.85 2.32 18.61  1  1    4    1
> # Or use additional variables to break the tie:
> mtcars %>% slice_min(tibble(cyl, mpg), n = 1)
            mpg cyl disp  hp drat   wt qsec vs am gear carb
Volvo 142E 21.4   4  121 109 4.11 2.78 18.6  1  1    4    2
> 
> # slice_sample() allows you to random select with or without replacement
> mtcars %>% slice_sample(n = 5)
                  mpg cyl disp  hp drat    wt  qsec vs am gear carb
Pontiac Firebird 19.2   8  400 175 3.08 3.845 17.05  0  0    3    2
Hornet 4 Drive   21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
Duster 360       14.3   8  360 245 3.21 3.570 15.84  0  0    3    4
Mazda RX4        21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag    21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
> mtcars %>% slice_sample(n = 5, replace = TRUE)
                mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
AMC Javelin    15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Merc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SLC    15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
> 
> # you can optionally weight by a variable - this code weights by the
> # physical weight of the cars, so heavy cars are more likely to get
> # selected
> mtcars %>% slice_sample(weight_by = wt, n = 5)
                  mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Pontiac Firebird 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Merc 450SE       16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 230         22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Dodge Challenger 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
Ferrari Dino     19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
> 
> # Group wise operation ----------------------------------------
> df <- tibble(
+   group = rep(c("a", "b", "c"), c(1, 2, 4)),
+   x = runif(7)
+ )
> 
> # All slice helpers operate per group, silently truncating to the group
> # size, so the following code works without error
> df %>% group_by(group) %>% slice_head(n = 2)
# A tibble: 5 × 2
# Groups:   group [3]
  group     x
  <chr> <dbl>
1 a     0.498
2 b     0.718
3 b     0.992
4 c     0.380
5 c     0.777
> 
> # When specifying the proportion of rows to include non-integer sizes
> # are rounded down, so group a gets 0 rows
> df %>% group_by(group) %>% slice_head(prop = 0.5)
# A tibble: 3 × 2
# Groups:   group [2]
  group     x
  <chr> <dbl>
1 b     0.718
2 c     0.380
3 c     0.777
> 
> # Filter equivalents --------------------------------------------
> # slice() expressions can often be written to use `filter()` and
> # `row_number()`, which can also be translated to SQL. For many databases,
> # you'll need to supply an explicit variable to use to compute the row number.
> filter(mtcars, row_number() == 1L)
          mpg cyl disp  hp drat   wt  qsec vs am gear carb
Mazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4
> filter(mtcars, row_number() == n())
            mpg cyl disp  hp drat   wt qsec vs am gear carb
Volvo 142E 21.4   4  121 109 4.11 2.78 18.6  1  1    4    2
> filter(mtcars, between(row_number(), 5, n()))
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("slice", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("src_dbi")
> ### * src_dbi
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: src_dbi
> ### Title: Source for database backends
> ### Aliases: src_dbi src_mysql src_postgres src_sqlite
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Don't show: 
> if (requireNamespace("dbplyr", quietly = TRUE) && requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
+ copy_to(con, mtcars)
+ 
+ # To retrieve a single table from a source, use `tbl()`
+ mtcars <- con %>% tbl("mtcars")
+ mtcars
+ 
+ # You can also use pass raw SQL if you want a more sophisticated query
+ con %>% tbl(sql("SELECT * FROM mtcars WHERE cyl == 8"))
+ ## Don't show: 
+ }) # examplesIf
> con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
> copy_to(con, mtcars)
> mtcars <- con %>% tbl("mtcars")
> mtcars
# Source:   table<`mtcars`> [?? x 11]
# Database: sqlite 3.46.0 [:memory:]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4
 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4
 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1
 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1
 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1
 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2
 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2
10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4
# ℹ more rows
> con %>% tbl(sql("SELECT * FROM mtcars WHERE cyl == 8"))
# Source:   SQL [?? x 11]
# Database: sqlite 3.46.0 [:memory:]
     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2
 2  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4
 3  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3
 4  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3
 5  15.2     8  276.   180  3.07  3.78  18       0     0     3     3
 6  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4
 7  10.4     8  460    215  3     5.42  17.8     0     0     3     4
 8  14.7     8  440    230  3.23  5.34  17.4     0     0     3     4
 9  15.5     8  318    150  2.76  3.52  16.9     0     0     3     2
10  15.2     8  304    150  3.15  3.44  17.3     0     0     3     2
# ℹ more rows
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("src_dbi", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("starwars")
> ### * starwars
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: starwars
> ### Title: Starwars characters
> ### Aliases: starwars
> ### Keywords: datasets
> 
> ### ** Examples
> 
> starwars
# A tibble: 87 × 14
   name     height  mass hair_color skin_color eye_color birth_year sex   gender
   <chr>     <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> 
 1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…
 2 C-3PO       167    75 <NA>       gold       yellow         112   none  mascu…
 3 R2-D2        96    32 <NA>       white, bl… red             33   none  mascu…
 4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
 5 Leia Or…    150    49 brown      light      brown           19   fema… femin…
 6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
 7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…
 8 R5-D4        97    32 <NA>       white, red red             NA   none  mascu…
 9 Biggs D…    183    84 black      light      brown           24   male  mascu…
10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…
# ℹ 77 more rows
# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,
#   vehicles <list>, starships <list>
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("starwars", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("storms")
> ### * storms
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: storms
> ### Title: Storm tracks data
> ### Aliases: storms
> ### Keywords: datasets
> 
> ### ** Examples
> 
> storms
# A tibble: 19,537 × 13
   name   year month   day  hour   lat  long status      category  wind pressure
   <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>          <dbl> <int>    <int>
 1 Amy    1975     6    27     0  27.5 -79   tropical d…       NA    25     1013
 2 Amy    1975     6    27     6  28.5 -79   tropical d…       NA    25     1013
 3 Amy    1975     6    27    12  29.5 -79   tropical d…       NA    25     1013
 4 Amy    1975     6    27    18  30.5 -79   tropical d…       NA    25     1013
 5 Amy    1975     6    28     0  31.5 -78.8 tropical d…       NA    25     1012
 6 Amy    1975     6    28     6  32.4 -78.7 tropical d…       NA    25     1012
 7 Amy    1975     6    28    12  33.3 -78   tropical d…       NA    25     1011
 8 Amy    1975     6    28    18  34   -77   tropical d…       NA    30     1006
 9 Amy    1975     6    29     0  34.4 -75.8 tropical s…       NA    35     1004
10 Amy    1975     6    29     6  34   -74.8 tropical s…       NA    40     1002
# ℹ 19,527 more rows
# ℹ 2 more variables: tropicalstorm_force_diameter <int>,
#   hurricane_force_diameter <int>
> 
> # Show a few recent storm paths
> if (requireNamespace("ggplot2", quietly = TRUE)) {
+   library(ggplot2)
+   storms %>%
+     filter(year >= 2000) %>%
+     ggplot(aes(long, lat, color = paste(year, name))) +
+     geom_path(show.legend = FALSE) +
+     facet_wrap(~year)
+ }
> 
> storms
# A tibble: 19,537 × 13
   name   year month   day  hour   lat  long status      category  wind pressure
   <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>          <dbl> <int>    <int>
 1 Amy    1975     6    27     0  27.5 -79   tropical d…       NA    25     1013
 2 Amy    1975     6    27     6  28.5 -79   tropical d…       NA    25     1013
 3 Amy    1975     6    27    12  29.5 -79   tropical d…       NA    25     1013
 4 Amy    1975     6    27    18  30.5 -79   tropical d…       NA    25     1013
 5 Amy    1975     6    28     0  31.5 -78.8 tropical d…       NA    25     1012
 6 Amy    1975     6    28     6  32.4 -78.7 tropical d…       NA    25     1012
 7 Amy    1975     6    28    12  33.3 -78   tropical d…       NA    25     1011
 8 Amy    1975     6    28    18  34   -77   tropical d…       NA    30     1006
 9 Amy    1975     6    29     0  34.4 -75.8 tropical s…       NA    35     1004
10 Amy    1975     6    29     6  34   -74.8 tropical s…       NA    40     1002
# ℹ 19,527 more rows
# ℹ 2 more variables: tropicalstorm_force_diameter <int>,
#   hurricane_force_diameter <int>
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("storms", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:ggplot2'

> nameEx("summarise")
> ### * summarise
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: summarise
> ### Title: Summarise each group down to one row
> ### Aliases: summarise summarize
> 
> ### ** Examples
> 
> # A summary applied to ungrouped tbl returns a single row
> mtcars %>%
+   summarise(mean = mean(disp), n = n())
      mean  n
1 230.7219 32
> 
> # Usually, you'll want to group first
> mtcars %>%
+   group_by(cyl) %>%
+   summarise(mean = mean(disp), n = n())
# A tibble: 3 × 3
    cyl  mean     n
  <dbl> <dbl> <int>
1     4  105.    11
2     6  183.     7
3     8  353.    14
> 
> # Each summary call removes one grouping level (since that group
> # is now just a single row)
> mtcars %>%
+   group_by(cyl, vs) %>%
+   summarise(cyl_n = n()) %>%
+   group_vars()
`summarise()` has grouped output by 'cyl'. You can override using the `.groups`
argument.
[1] "cyl"
> 
> # BEWARE: reusing variables may lead to unexpected results
> mtcars %>%
+   group_by(cyl) %>%
+   summarise(disp = mean(disp), sd = sd(disp))
# A tibble: 3 × 3
    cyl  disp    sd
  <dbl> <dbl> <dbl>
1     4  105.    NA
2     6  183.    NA
3     8  353.    NA
> 
> # Refer to column names stored as strings with the `.data` pronoun:
> var <- "mass"
> summarise(starwars, avg = mean(.data[[var]], na.rm = TRUE))
# A tibble: 1 × 1
    avg
  <dbl>
1  97.3
> # Learn more in ?rlang::args_data_masking
> 
> # In dplyr 1.1.0, returning multiple rows per group was deprecated in favor
> # of `reframe()`, which never messages and always returns an ungrouped
> # result:
> mtcars %>%
+    group_by(cyl) %>%
+    summarise(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75))
Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in
dplyr 1.1.0.
ℹ Please use `reframe()` instead.
ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`
  always returns an ungrouped data frame and adjust accordingly.
`summarise()` has grouped output by 'cyl'. You can override using the `.groups`
argument.
# A tibble: 6 × 3
# Groups:   cyl [3]
    cyl    qs  prob
  <dbl> <dbl> <dbl>
1     4  78.8  0.25
2     4 121.   0.75
3     6 160    0.25
4     6 196.   0.75
5     8 302.   0.25
6     8 390    0.75
> # ->
> mtcars %>%
+    group_by(cyl) %>%
+    reframe(qs = quantile(disp, c(0.25, 0.75)), prob = c(0.25, 0.75))
# A tibble: 6 × 3
    cyl    qs  prob
  <dbl> <dbl> <dbl>
1     4  78.8  0.25
2     4 121.   0.75
3     6 160    0.25
4     6 196.   0.75
5     8 302.   0.25
6     8 390    0.75
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("summarise", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("summarise_all")
> ### * summarise_all
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: summarise_all
> ### Title: Summarise multiple columns
> ### Aliases: summarise_all summarise_if summarise_at summarize_all
> ###   summarize_if summarize_at
> ### Keywords: internal
> 
> ### ** Examples
> 
> # The _at() variants directly support strings:
> starwars %>%
+   summarise_at(c("height", "mass"), mean, na.rm = TRUE)
# A tibble: 1 × 2
  height  mass
   <dbl> <dbl>
1   175.  97.3
> # ->
> starwars %>% summarise(across(c("height", "mass"), ~ mean(.x, na.rm = TRUE)))
# A tibble: 1 × 2
  height  mass
   <dbl> <dbl>
1   175.  97.3
> 
> # You can also supply selection helpers to _at() functions but you have
> # to quote them with vars():
> starwars %>%
+   summarise_at(vars(height:mass), mean, na.rm = TRUE)
# A tibble: 1 × 2
  height  mass
   <dbl> <dbl>
1   175.  97.3
> # ->
> starwars %>%
+   summarise(across(height:mass, ~ mean(.x, na.rm = TRUE)))
# A tibble: 1 × 2
  height  mass
   <dbl> <dbl>
1   175.  97.3
> 
> # The _if() variants apply a predicate function (a function that
> # returns TRUE or FALSE) to determine the relevant subset of
> # columns. Here we apply mean() to the numeric columns:
> starwars %>%
+   summarise_if(is.numeric, mean, na.rm = TRUE)
# A tibble: 1 × 3
  height  mass birth_year
   <dbl> <dbl>      <dbl>
1   175.  97.3       87.6
> starwars %>%
+   summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE)))
# A tibble: 1 × 3
  height  mass birth_year
   <dbl> <dbl>      <dbl>
1   175.  97.3       87.6
> 
> by_species <- iris %>%
+   group_by(Species)
> 
> # If you want to apply multiple transformations, pass a list of
> # functions. When there are multiple functions, they create new
> # variables instead of modifying the variables in place:
> by_species %>%
+   summarise_all(list(min, max))
# A tibble: 3 × 9
  Species    Sepal.Length_fn1 Sepal.Width_fn1 Petal.Length_fn1 Petal.Width_fn1
  <fct>                 <dbl>           <dbl>            <dbl>           <dbl>
1 setosa                  4.3             2.3              1               0.1
2 versicolor              4.9             2                3               1  
3 virginica               4.9             2.2              4.5             1.4
# ℹ 4 more variables: Sepal.Length_fn2 <dbl>, Sepal.Width_fn2 <dbl>,
#   Petal.Length_fn2 <dbl>, Petal.Width_fn2 <dbl>
> # ->
> by_species %>%
+   summarise(across(everything(), list(min = min, max = max)))
# A tibble: 3 × 9
  Species    Sepal.Length_min Sepal.Length_max Sepal.Width_min Sepal.Width_max
  <fct>                 <dbl>            <dbl>           <dbl>           <dbl>
1 setosa                  4.3              5.8             2.3             4.4
2 versicolor              4.9              7               2               3.4
3 virginica               4.9              7.9             2.2             3.8
# ℹ 4 more variables: Petal.Length_min <dbl>, Petal.Length_max <dbl>,
#   Petal.Width_min <dbl>, Petal.Width_max <dbl>
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("summarise_all", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("top_n")
> ### * top_n
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: top_n
> ### Title: Select top (or bottom) n rows (by value)
> ### Aliases: top_n top_frac
> ### Keywords: internal
> 
> ### ** Examples
> 
> df <- data.frame(x = c(6, 4, 1, 10, 3, 1, 1))
> 
> df %>% top_n(2)  # highest values
Selecting by x
   x
1  6
2 10
> df %>% top_n(-2) # lowest values
Selecting by x
  x
1 1
2 1
3 1
> # now use
> df %>% slice_max(x, n = 2)
   x
1 10
2  6
> df %>% slice_min(x, n = 2)
  x
1 1
2 1
3 1
> 
> # top_frac() -> prop argument of slice_min()/slice_max()
> df %>% top_frac(.5)
Selecting by x
   x
1  6
2  4
3 10
> # ->
> df %>% slice_max(x, prop = 0.5)
   x
1 10
2  6
3  4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("top_n", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("with_groups")
> ### * with_groups
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: with_groups
> ### Title: Perform an operation with temporary groups
> ### Aliases: with_groups
> ### Keywords: internal
> 
> ### ** Examples
> 
> df <- tibble(g = c(1, 1, 2, 2, 3), x = runif(5))
> 
> # Old
> df %>%
+   with_groups(g, mutate, x_mean = mean(x))
# A tibble: 5 × 3
      g     x x_mean
  <dbl> <dbl>  <dbl>
1     1 0.266  0.319
2     1 0.372  0.319
3     2 0.573  0.741
4     2 0.908  0.741
5     3 0.202  0.202
> # New
> df %>% mutate(x_mean = mean(x), .by = g)
# A tibble: 5 × 3
      g     x x_mean
  <dbl> <dbl>  <dbl>
1     1 0.266  0.319
2     1 0.372  0.319
3     2 0.573  0.741
4     2 0.908  0.741
5     3 0.202  0.202
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("with_groups", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  2.78 0.23 15.27 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
